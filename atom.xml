<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一纸墨迹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ku-cat.com/"/>
  <updated>2018-04-08T01:40:12.184Z</updated>
  <id>http://blog.ku-cat.com/</id>
  
  <author>
    <name>Ben</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python多线程并发限制</title>
    <link href="http://blog.ku-cat.com/2018/04/08/python-Thread/"/>
    <id>http://blog.ku-cat.com/2018/04/08/python-Thread/</id>
    <published>2018-04-08T01:08:05.000Z</published>
    <updated>2018-04-08T01:40:12.184Z</updated>
    
    <content type="html"><![CDATA[<p>python 在使用多线程的时候，我们有时需要对并发限制进行控制，即同一时间只能多少线程在工作，控制并发数，确保机器资源的有效利用。</p><h3 id="信号量：class-threading-Semaphore-value"><a href="#信号量：class-threading-Semaphore-value" class="headerlink" title="信号量：class threading.Semaphore([value])"></a>信号量：class threading.Semaphore([value])</h3><blockquote><p>values是一个内部计数，values默认是1，如果小于0，则会抛出 ValueError 异常，可以用于控制线程数并发数<br>1.acquire([blocking])<br>2.release()</p></blockquote><p>例：数据库的连接数控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxconnections = <span class="number">5</span> <span class="comment"># 最多5个线程同时运行</span></span><br><span class="line">...</span><br><span class="line">pool_sema = BoundedSemaphore(value=maxconnections)</span><br><span class="line"></span><br><span class="line">pool_sema.acquire() <span class="comment"># 开始时候计数</span></span><br><span class="line">conn = connectdb()</span><br><span class="line"><span class="meta">... </span>use connection ...</span><br><span class="line">conn.close()</span><br><span class="line">pool_sema.release() <span class="comment"># 完成释放，新的线程可以继续运行</span></span><br></pre></td></tr></table></figure><p>SpiderRobot类的pageAnalysis函数创建队列中数量的线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pageAnalysis</span><span class="params">(self)</span>:</span></span><br><span class="line">    semlock = threading.BoundedSemaphore(self.maxconnections)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.queue.qsize()):</span><br><span class="line">        semlock.acquire() <span class="comment"># 开始时候计数</span></span><br><span class="line">        details = DetailsAnalysis() <span class="comment"># 该对象继承threading</span></span><br><span class="line">        details.initData(self.queue.get(), semlock)</span><br><span class="line">        details.start() <span class="comment">#线程开始</span></span><br></pre></td></tr></table></figure><p>数据保存线程结束，调用self.semlock.release() 释放线程，进程继续进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveData</span><span class="params">(self)</span>:</span></span><br><span class="line">    cursor = self.db.cursor()</span><br><span class="line">    sql = <span class="string">"insert into company (company_name,name,mobile,phone,address) value ('"</span> + self.companyName + <span class="string">"','"</span> + self.name + <span class="string">"','"</span> + self.mobile + <span class="string">"','"</span> + self.telephone + <span class="string">"','"</span> + self.address + <span class="string">"')"</span></span><br><span class="line">    print(<span class="string">"sql:"</span>,sql)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    self.db.commit()</span><br><span class="line">    self.semlock.release() <span class="comment"># 当前任务完成，线程释放</span></span><br></pre></td></tr></table></figure><p>以上的代码我们有self.queue.qsize()数量的任务需要去做，我们希望使用多线程并发的形式去处理这些任务，以达到高效的处理，但是由于资源是有限的，所以我们不能够有多少任务就创建多少线程，每个线程是需要占用内存和系统资源的，数量过大可能会消耗掉机器所有资源最终可能导致系统启机，我们肯定希望在同一时间有多少线程在运行是可控的。</p><p>以上的方法可以有效的控制同一时间运行的线程数量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python 在使用多线程的时候，我们有时需要对并发限制进行控制，即同一时间只能多少线程在工作，控制并发数，确保机器资源的有效利用。&lt;/p&gt;
&lt;h3 id=&quot;信号量：class-threading-Semaphore-value&quot;&gt;&lt;a href=&quot;#信号量：class-t
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python, thread" scheme="http://blog.ku-cat.com/tags/python-thread/"/>
    
  </entry>
  
  <entry>
    <title>nodejs的process.nextTick()的原理及应用场景</title>
    <link href="http://blog.ku-cat.com/2018/04/04/nodejs-process/"/>
    <id>http://blog.ku-cat.com/2018/04/04/nodejs-process/</id>
    <published>2018-04-04T08:17:42.000Z</published>
    <updated>2018-04-04T09:45:40.017Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs的API原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(callback[, ...args])</span><br></pre></td></tr></table></figure><ul><li>callback  \&lt;Function> </li><li>…args <any> 调用 callback时传递给它的额外参数</any></li></ul><p>说明：process.nextTick()方法将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。</p><p>这种方式不是setTimeout(fn, 0)的别名。它更加有效率。事件轮询随后的ticks 调用，会在任何I/O事件（包括定时器）之前运行。</p><p>以上的是API的原文说明，说得比较明白了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick callback'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'scheduled'</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// scheduled</span></span><br><span class="line"><span class="comment">// nextTick callback 最后执行，nextTick的callback被放到任务队列的最后面。要到下一次tick时被执行。</span></span><br></pre></td></tr></table></figure><p>Node.js是单线程的，除了系统IO之外，在它的事件轮询过程中，同一时间只会处理一个事件。你可以把事件轮询想象成一个大的队列，在每个时间点上，系统只会处理一个事件。即使你的电脑有多个CPU核心，你也无法同时并行的处理多个事件。但也就是这种特性使得node.js适合处理I／O型的应用，不适合那种CPU运算型的应用。在每个I／O型的应用中，你只需要给每一个输入输出定义一个回调函数即可，他们会自动加入到事件轮询的处理队列里。当I／O操作完成后，这个回调函数会被触发。然后系统会继续处理其他的请求。</p><p>–</p><p>在这种处理模式下，process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。我们来看一个例子。例子中有一个foo()，你想在下一个时间点上调用他，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.nextTick(foo);</span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><p>运行上面的代码，你从下面终端打印的信息会看到，”bar”的输出在“foo”的前面。这就验证了上面的说法，foo()是在下一个时间点运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>你也可以使用setTimeout()函数来达到貌似同样的执行效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(foo, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><p>但在内部的处理机制上，process.nextTick()和setTimeout(fn, 0)是不同的，process.nextTick()不是一个单纯的延时，他有更多的特性。</p><p><strong>更精确的说</strong>：<font color="red">process.nextTick()定义的调用会创建一个新的子堆栈。在当前的栈里，你可以执行任意多的操作。但一旦调用netxTick，函数就必须返回到父堆栈。然后事件轮询机制又重新等待处理新的事件，如果发现nextTick的调用，就会创建一个新的栈。</font></p><h3 id="应用场景：-什么情况下使用process-nextTick-："><a href="#应用场景：-什么情况下使用process-nextTick-：" class="headerlink" title="应用场景： 什么情况下使用process.nextTick()："></a>应用场景： 什么情况下使用process.nextTick()：</h3><h4 id="1-在多个事件里交叉执行CPU运算密集型的任务："><a href="#1-在多个事件里交叉执行CPU运算密集型的任务：" class="headerlink" title="1. 在多个事件里交叉执行CPU运算密集型的任务："></a>1. 在多个事件里交叉执行CPU运算密集型的任务：</h4><p>在下面的例子里有一个compute()，我们希望这个函数尽可能持续的执行，来进行一些运算密集的任务。</p><p>但与此同时，我们还希望系统不要被这个函数堵塞住，还需要能响应处理别的事件。这个应用模式就像一个单线程的web服务server。在这里我们就可以使用process.nextTick()来交叉执行compute()和正常的事件响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// performs complicated calculations continuously</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    process.nextTick(compute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">     res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">     res.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line">compute();</span><br></pre></td></tr></table></figure><p>在这种模式下，我们不需要递归的调用compute()，我们只需要在事件循环中使用process.nextTick()定义compute()在下一个时间点执行即可。在这个过程中，如果有新的http请求进来，事件循环机制会先处理新的请求，然后再调用compute()。反之，如果你把compute()放在一个递归调用里，那系统就会一直阻塞在compute()里，无法处理新的http请求了。你可以自己试试。</p><p>当然，我们无法通过process.nextTick()来获得多CPU下并行执行的真正好处，这只是模拟同一个应用在CPU上分段执行而已。</p><h4 id="2-保持回调函数异步执行的原则"><a href="#2-保持回调函数异步执行的原则" class="headerlink" title="2. 保持回调函数异步执行的原则"></a>2. 保持回调函数异步执行的原则</h4><p>当你给一个函数定义一个回调函数时，你要确保这个回调是被异步执行的。下面我们看一个例子，例子中的回调违反了这一原则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFake</span>(<span class="params">data, callback</span>) </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span>(data === <span class="string">'foo'</span>) callback(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span> callback(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFake(<span class="string">'bar'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this callback is actually called synchronously!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么这样不好呢？我们来看Node.js 文档里一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = net.connect(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">    client.write(<span class="string">'world!\r\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的代码里，如果因为某种原因，net.connect()变成同步执行的了，回调函数就会被立刻执行，因此回调函数写到客户端的变量就永远不会被初始化了。</p><p>这种情况下我们就可以使用process.nextTick()把上面asyncFake()改成异步执行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncReal</span>(<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(data === <span class="string">'foo'</span>);       </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-用在事件触发过程中"><a href="#3-用在事件触发过程中" class="headerlink" title="3.用在事件触发过程中"></a>3.用在事件触发过程中</h4><p>来看一个例子，你想写一个库实现这样的功能：从源文件里读取数据，当读取完毕后，触发一个事件同时传递读取的数据。可能你会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StreamLibrary</span>(<span class="params">resourceName</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from the file, and for every chunk read, do:        </span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, chunkRead);       </span><br><span class="line">&#125;</span><br><span class="line">StreamLibrary.prototype.__proto__ = EventEmitter.prototype;   <span class="comment">// inherit from EventEmitter</span></span><br></pre></td></tr></table></figure><p>下面是一段调用这个库的客户端程序，我们想在程序中监听这些事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> StreamLibrary(<span class="string">'fooResource'</span>);</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Reading has started'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received: '</span> + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是上面的代码中，将永远接收不到“start”事件，因为在这个库实例化的时候，“start”事件会被立刻触发执行，但此时事件的回调函数还没有准备好，所以在客户端根本无法接收到这个事件。同样，我们可以用process.nextTick()来改写事件触发的过程，下面是一个正确的版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StreamLibrary</span>(<span class="params">resourceName</span>) </span>&#123;      </span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.emit(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read from the file, and for every chunk read, do:        </span></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, chunkRead);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是process.nextTick()的基本用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nodejs的API原型：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co
      
    
    </summary>
    
      <category term="nodejs" scheme="http://blog.ku-cat.com/categories/nodejs/"/>
    
    
      <category term="nodejs, process, nextTick" scheme="http://blog.ku-cat.com/tags/nodejs-process-nextTick/"/>
    
  </entry>
  
  <entry>
    <title>django登录写入session的操作</title>
    <link href="http://blog.ku-cat.com/2018/04/04/python-django-session/"/>
    <id>http://blog.ku-cat.com/2018/04/04/python-django-session/</id>
    <published>2018-04-04T00:25:42.000Z</published>
    <updated>2018-04-04T00:30:17.801Z</updated>
    
    <content type="html"><![CDATA[<p>用户登录是需要把用户的相关数据写入session的，在django中用户登录的操作代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkuser</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:  </span><br><span class="line">        user = request.POST.get(<span class="string">'username'</span>)  </span><br><span class="line">        passwd = request.POST.get(<span class="string">'password'</span>)  </span><br><span class="line">        <span class="keyword">print</span> user,passwd  </span><br><span class="line">        <span class="keyword">try</span>:  </span><br><span class="line">            passwd_db = User.objects.get(username=user).password  </span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            messages.add_message(request,messages.WARNING,<span class="string">'找不到用户'</span>)  </span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">'showdb/login.html'</span>,&#123;<span class="string">'login_info_list'</span>:<span class="string">"请使用正确的账号密码登陆"</span>&#125;,)  </span><br><span class="line">        <span class="keyword">if</span> passwd == passwd_db :  </span><br><span class="line">            request.session[<span class="string">'username'</span>] = user  </span><br><span class="line">            request.session.set_expiry(<span class="number">600</span>)  </span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">'showdb/index.html'</span>,&#123;  </span><br><span class="line">            <span class="string">'welcome'</span>:<span class="string">"欢迎你"</span>&#125;)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            messages.add_message(request,messages.WARNING,<span class="string">'密码错误'</span>)  </span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">'showdb/login.html'</span>,&#123;<span class="string">'login_info_list'</span>:<span class="string">"请使用正确的账号密码登陆"</span>&#125;,)</span><br></pre></td></tr></table></figure><p>以上是登录部分的代码，写入session的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.session[<span class="string">'username'</span>] = user  <span class="comment"># 用户名写入session</span></span><br><span class="line">request.session.set_expiry(<span class="number">600</span>) <span class="comment"># 设置session有效时间。</span></span><br></pre></td></tr></table></figure><p>前端代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> request.session.username %&#125;  </span><br><span class="line">    &lt;h4 style='font-family:楷体;'&gt;&#123;&#123; welcome&#125;&#125; &#123;&#123; request.session.username &#125;&#125; &lt;/h4&gt;  </span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;  </span><br><span class="line">    &lt;h3 style='font-family:楷体;'&gt;请重新登陆&lt;/h3&gt;  </span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户登录是需要把用户的相关数据写入session的，在django中用户登录的操作代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python,django" scheme="http://blog.ku-cat.com/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>mac下搭建django2.0的开发环境</title>
    <link href="http://blog.ku-cat.com/2018/04/03/python-django/"/>
    <id>http://blog.ku-cat.com/2018/04/03/python-django/</id>
    <published>2018-04-03T13:32:13.000Z</published>
    <updated>2018-04-04T08:29:29.381Z</updated>
    
    <content type="html"><![CDATA[<p>mac 下搭建django2.0的开发环境，mac上默认的python版本是2.7，django需要的是python3以上的版本。所以我们需要再安装一个python3.5的版本。python2.7和python3.5可以共存的。直接安装就可以了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V <span class="comment">#查看python版本，默认的mac上的python版本是2.7</span></span><br></pre></td></tr></table></figure><p>我们可以到<a href="https://www.python.org上下载安装python3.0安装文件，是pyton-3.6.5-macos.pkg文件，双击安装即可。" target="_blank" rel="noopener">https://www.python.org上下载安装python3.0安装文件，是pyton-3.6.5-macos.pkg文件，双击安装即可。</a></p><p>安装完成后，查看版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  django python -V</span><br><span class="line">Python 2.7.10</span><br><span class="line">➜  django python -V</span><br><span class="line">Python 2.7.10</span><br><span class="line">➜  django python3 -V</span><br><span class="line">Python 3.6.5</span><br></pre></td></tr></table></figure><p>如果没有安装pip，先安装pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  django sudo easy_install pip</span><br><span class="line">Password:</span><br><span class="line">Searching for pip</span><br><span class="line">Reading https://pypi.python.org/simple/pip/</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这里的pip是2.7的pip，只能安装django1.x版本，要安装django2.0的版本需要安装pip3版本。安装pip3的方法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py | python3</span><br></pre></td></tr></table></figure><p>使用上面的命令用python3，安装pip3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  django curl https://bootstrap.pypa.io/get-pip.py | python3</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 1738k  100 1738k    0     0  1610k      0  0:00:01  0:00:01 --:--:-- 1612k</span><br><span class="line">Cache entry deserialization failed, entry ignored</span><br><span class="line">Requirement already up-to-date: pip in /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages</span><br><span class="line">Collecting wheel</span><br><span class="line">  Downloading wheel-0.31.0-py2.py3-none-any.whl (41kB)</span><br><span class="line">    100% |████████████████████████████████| 51kB 533kB/s </span><br><span class="line">Installing collected packages: wheel</span><br><span class="line">Successfully installed wheel-0.31.0</span><br></pre></td></tr></table></figure><p>安装成功后，检查版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  django pip -V</span><br><span class="line">pip 10.0.0b2 from /Library/Python/2.7/site-packages/pip-10.0.0b2-py2.7.egg/pip (python 2.7)</span><br><span class="line">➜  django pip --version</span><br><span class="line">pip 10.0.0b2 from /Library/Python/2.7/site-packages/pip-10.0.0b2-py2.7.egg/pip (python 2.7)</span><br><span class="line">➜  django pip3</span><br></pre></td></tr></table></figure><p>使用pip3 安装django pip3</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  django pip3 install Django==2.0.4</span><br><span class="line">Collecting Django==2.0.4</span><br><span class="line">  Cache entry deserialization failed, entry ignored</span><br><span class="line">  Downloading Django-2.0.4-py3-none-any.whl (7.1MB)</span><br><span class="line">    100% |████████████████████████████████| 7.1MB 267kB/s </span><br><span class="line">Collecting pytz (from Django==2.0.4)</span><br><span class="line">  Downloading pytz-2018.3-py2.py3-none-any.whl (509kB)</span><br><span class="line">    100% |████████████████████████████████| 512kB 2.5MB/s </span><br><span class="line">Installing collected packages: pytz, Django</span><br><span class="line">Successfully installed Django-2.0.4 pytz-2018.3</span><br></pre></td></tr></table></figure><p>成功安装django2.0.4版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac 下搭建django2.0的开发环境，mac上默认的python版本是2.7，django需要的是python3以上的版本。所以我们需要再安装一个python3.5的版本。python2.7和python3.5可以共存的。直接安装就可以了。&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python,django" scheme="http://blog.ku-cat.com/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>Python 用hashlib求中文字符串的MD5值</title>
    <link href="http://blog.ku-cat.com/2018/04/03/python-md5/"/>
    <id>http://blog.ku-cat.com/2018/04/03/python-md5/</id>
    <published>2018-04-03T11:06:03.000Z</published>
    <updated>2018-04-03T11:11:09.219Z</updated>
    
    <content type="html"><![CDATA[<p>使用过hashlib库的遇到过以下的错误:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode-objects must be encoded before hashing</span><br></pre></td></tr></table></figure><p>意思是在进行md5哈希运算前，需要对数据进行编码。而且在不同版本的Python下还有所不同。hashlib.md5(data)函数中，data参数的类型应该是bytes。也就是说我们在进行hash前必须把数据转换成bytes类型，对于C程序而言似乎没有类似问题，指针强制转换就OK了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def md5(str):</span><br><span class="line">    m2 = hashlib.md5()</span><br><span class="line">    m2.update(str.encode(&apos;utf8&apos;))</span><br><span class="line">    return m2.hexdigest()</span><br></pre></td></tr></table></figure><p>先简单处理一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用过hashlib库的遇到过以下的错误:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.ku-cat.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>django添加css等静态文件</title>
    <link href="http://blog.ku-cat.com/2018/04/03/python-django-static/"/>
    <id>http://blog.ku-cat.com/2018/04/03/python-django-static/</id>
    <published>2018-04-03T05:16:03.000Z</published>
    <updated>2018-04-03T05:35:15.493Z</updated>
    
    <content type="html"><![CDATA[<p>django 中访问 css 等静态文件必须以 url 的形式去访问，即必须配置 urls.py 的访问路径<br>首先在 settings.py 中添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT = os.path.join(os.path.dirname(os.path.dirname(__file__)), <span class="string">'static'</span>)</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    (<span class="string">'css'</span>, os.path.join(STATIC_ROOT, <span class="string">'css'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)),</span><br><span class="line">    (<span class="string">'js'</span>, os.path.join(STATIC_ROOT, <span class="string">'js'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)),</span><br><span class="line">    (<span class="string">'image'</span>, os.path.join(STATIC_ROOT, <span class="string">'image'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)),</span><br><span class="line">    (<span class="string">'upload'</span>, os.path.join(STATIC_ROOT, <span class="string">'upload'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)),</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p>其中__file__ 指的是调用 css 的html 文件所在的路径</p><p>然后在 urls.py 中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^static/(?P&lt;path&gt;.*)$'</span>, <span class="string">'django.views.static.serve'</span>, &#123;<span class="string">'document_root'</span>: settings.STATIC_ROOT&#125;)</span><br></pre></td></tr></table></figure><p>最后在 register.html 中引用 css 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"/static/css/register.css"</span>&gt;</span><br></pre></td></tr></table></figure><p>此处调用 django.views.static.serve 方法去解析具体的路径</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># …or create a new repository on the command line</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"# test1"</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin git@github.com:BenVim/test1.git</span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># …or push an existing repository from the command line</span></span><br><span class="line">git remote add origin git@github.com:BenVim/test1.git</span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># …or import code from another repository</span></span><br><span class="line">You can initialize this repository with code from a Subversion, Mercurial, or TFS project.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;django 中访问 css 等静态文件必须以 url 的形式去访问，即必须配置 urls.py 的访问路径&lt;br&gt;首先在 settings.py 中添加：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python, django" scheme="http://blog.ku-cat.com/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>python-virtualenv 创建独立的python运行环境。</title>
    <link href="http://blog.ku-cat.com/2018/04/03/python-virtualenv/"/>
    <id>http://blog.ku-cat.com/2018/04/03/python-virtualenv/</id>
    <published>2018-04-03T02:27:40.000Z</published>
    <updated>2018-04-03T03:35:44.293Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。如果要开发2.7版本的应用的话，则需要2.7的环境，这种情况可以使用virtualenv创建各自独立的运行环境。</p><p>首先安装 virtualenv</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install virtualenv</span><br></pre></td></tr></table></figure><p>然后，假如我们要开发一个新的项目，需要一套独立的python运行环境，可以这么做：</p><p>第一步：创建目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  django mkdir ngrokProject</span><br><span class="line">➜  django <span class="built_in">cd</span> ngrokProject</span><br></pre></td></tr></table></figure><p>第二步，创建一个独立的Python运行环境，命名为venv</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ngrokProject virtualenv --no-site-packages venv</span><br><span class="line">New python executable <span class="keyword">in</span> /Users/ben/django/ngrokProject/venv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure><p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p><p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ngrokProject <span class="built_in">source</span> venv/bin/activate</span><br><span class="line">(venv) ➜  ngrokProject</span><br></pre></td></tr></table></figure><p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p><p>下面正常安装各种第三方包，并运行python命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv)Mac:myproject michael$ pip install jinja2</span><br><span class="line">...</span><br><span class="line">Successfully installed jinja2-2.7.3 markupsafe-0.23</span><br><span class="line">(venv)Mac:myproject michael$ python myapp.py</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p><p>退出当前的venv环境，使用deactivate命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv)Mac:myproject michael$ deactivate </span><br><span class="line">Mac:myproject michael$</span><br></pre></td></tr></table></figure><p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p><p>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p><p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p><p>virtualenv为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。如果要开发2.7版本的应用的话，则需要2.7的环境，这种情况可以使用virtualenv创建各自独立的运行环境。
      
    
    </summary>
    
      <category term="python" scheme="http://blog.ku-cat.com/categories/python/"/>
    
    
      <category term="python,virtualenv" scheme="http://blog.ku-cat.com/tags/python-virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>使用docker制作nginx环境</title>
    <link href="http://blog.ku-cat.com/2018/04/02/docker-nginx/"/>
    <id>http://blog.ku-cat.com/2018/04/02/docker-nginx/</id>
    <published>2018-04-02T13:43:04.000Z</published>
    <updated>2018-04-02T13:54:11.428Z</updated>
    
    <content type="html"><![CDATA[<p>使用docker构建开发运行环境有很多优势，能够保持本地与测试、生产环境的一致性。首先简单方法构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx # 获取nginx镜像</span><br></pre></td></tr></table></figure><p>运行docker挂载工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name myNginx -d -p 8080:80 -v /Users/ben/docker/nginx/www:/usr/share/nginx/html nginx</span><br><span class="line">b0167fd1d31bf7071589c10569e259392533c2ad0527ad0ccbb51ec9c62ecd6f</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">b0167fd1d31b        nginx               &quot;nginx -g &apos;daemon of…&quot;   27 seconds ago      Up 21 seconds       0.0.0.0:8080-&gt;80/tcp   Nginx</span><br></pre></td></tr></table></figure><p>本地的mac目录/Users/ben/docker/nginx/www 与 容器的/usr/share/nginx/html绑定。我们可以修改 /Users/ben/docker/nginx/www 中的内容，在地址栏输入 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 可以直接测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用docker构建开发运行环境有很多优势，能够保持本地与测试、生产环境的一致性。首先简单方法构建。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="docker" scheme="http://blog.ku-cat.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://blog.ku-cat.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Mac下挂载EFI分区</title>
    <link href="http://blog.ku-cat.com/2018/04/02/mac-os-efi/"/>
    <id>http://blog.ku-cat.com/2018/04/02/mac-os-efi/</id>
    <published>2018-04-02T05:31:21.000Z</published>
    <updated>2018-04-02T05:33:25.767Z</updated>
    
    <content type="html"><![CDATA[<p>Mac EFI分区默认是隐藏的，如果需要访问可以使用如下的方法重新挂载EFI分区。</p><ol><li>Discover the volume identifier for your EFI boot partition.</li></ol><p>Run this command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p>The output should look something like this:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk0</span><br><span class="line"> <span class="comment">#: TYPE                     NAME          SIZE       IDENTIFIER</span></span><br><span class="line"> 0: GUID_partition_scheme                  *251.0 GB  disk0</span><br><span class="line"> 1: EFI                                    209.7 MB   disk0s1</span><br><span class="line"> 2: Apple_HFS                Macintosh HD  250.1 GB   disk0s2</span><br><span class="line"> 3: Apple_Boot               Recovery HD   650.0 MB   disk0s3</span><br></pre></td></tr></table></figure><p>In this case, the volume identifier of the EFI partition is disk0s1</p><ol start="2"><li>Create a mount point.</li></ol><p>A mount point is a directory where a non-booted volume is mounted.  On Mac OS X, mount points are typically created in /Volumes.  We can create a directory called efi within /Volumes by running the following command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /Volumes/efi</span><br></pre></td></tr></table></figure><ol start="3"><li>Mount the EFI partition at the efi mount point.</li></ol><p>Run the command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t msdos /dev/disk0s1 /Volumes/efi</span><br></pre></td></tr></table></figure><p>That’s it.  Your EFI volume will be mounted.  Modify it at your own risk.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac EFI分区默认是隐藏的，如果需要访问可以使用如下的方法重新挂载EFI分区。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Discover the volume identifier for your EFI boot partition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Run this
      
    
    </summary>
    
      <category term="mac" scheme="http://blog.ku-cat.com/categories/mac/"/>
    
    
      <category term="mac,os" scheme="http://blog.ku-cat.com/tags/mac-os/"/>
    
  </entry>
  
  <entry>
    <title>node.js 版本控制 nvm</title>
    <link href="http://blog.ku-cat.com/2018/04/01/node-nvm/"/>
    <id>http://blog.ku-cat.com/2018/04/01/node-nvm/</id>
    <published>2018-04-01T11:40:22.000Z</published>
    <updated>2018-04-01T11:41:49.490Z</updated>
    
    <content type="html"><![CDATA[<p>node的版本实在是多，在两台mac上安装pomelo， 一台正常运行，一台运行报错，完全一样的代码，最后检查是node版本不一致，一个是9.3和9.8。后来安装nvm使用相同的9.3版后，一切正常了。</p><h3 id="nvm版本控制的安装"><a href="#nvm版本控制的安装" class="headerlink" title="nvm版本控制的安装"></a>nvm版本控制的安装</h3><p>我们使用brew安装nvm</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><p>安装完成后，需要在bash或zsh配置文件中设置一下，否则当你重新启动终端，node，npm环境变量都会失效。</p><p>安装好nvm后，输入如下命令，可以看到帮助信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info nvm</span><br></pre></td></tr></table></figure><p>输出如下信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">nvm: stable 0.33.8, HEAD</span><br><span class="line">Manage multiple Node.js versions</span><br><span class="line">https://github.com/creationix/nvm</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/nvm/0.33.8 (7 files, 135.5KB) *</span><br><span class="line">  Built from <span class="built_in">source</span> on 2018-03-31 at 20:58:44</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/nvm.rb</span><br><span class="line">==&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">Install HEAD version</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Please note that upstream has asked us to make explicit managing</span><br><span class="line">nvm via Homebrew is unsupported by them and you should check any</span><br><span class="line">problems against the standard nvm install method prior to reporting.</span><br><span class="line"></span><br><span class="line">You should create NVM<span class="string">'s working directory if it doesn'</span>t exist:</span><br><span class="line"></span><br><span class="line">  mkdir ~/.nvm</span><br><span class="line"></span><br><span class="line">Add the following to ~/.bash_profile or your desired shell</span><br><span class="line">configuration file:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">  . <span class="string">"/usr/local/opt/nvm/nvm.sh"</span></span><br><span class="line"></span><br><span class="line">You can <span class="built_in">set</span> <span class="variable">$NVM_DIR</span> to any location, but leaving it unchanged from</span><br><span class="line">/usr/<span class="built_in">local</span>/opt/nvm will destroy any nvm-installed Node installations</span><br><span class="line">upon upgrade/reinstall.</span><br><span class="line"></span><br><span class="line">Type `nvm <span class="built_in">help</span>` <span class="keyword">for</span> further information.</span><br><span class="line"></span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/<span class="built_in">local</span>/etc/bash_completion.d</span><br></pre></td></tr></table></figure><p>我们需要按照上面提供的方法,首先在用户更目录下 创建 .nvm 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.nvm</span><br></pre></td></tr></table></figure><p>然后把 nvm-exec 文件拷贝到你刚才新建的 .nvm 目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp $(brew --prefix nvm)/nvm-exec ~/.nvm/</span><br></pre></td></tr></table></figure><p>然后去编辑你的 bash 配置文件 $HOME/.bashrc ,如果你  使用 zsh 那么编辑 $HOME/.zshrc 配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>把下面的内容粘贴进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=~/.nvm</span><br><span class="line">source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure><p>最后让你的 shell 配置及时生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line"># 或</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="nvm的使用"><a href="#nvm的使用" class="headerlink" title="nvm的使用"></a>nvm的使用</h3><p>nvm使用方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote <span class="comment"># 查看可以安装的版本</span></span><br><span class="line">nvm ls <span class="comment"># 查看已经安装的版本</span></span><br><span class="line">nvm install &lt;version&gt; <span class="comment"># 安装一个指定的版本</span></span><br><span class="line"><span class="comment"># 上面的 version 可以指定你在 nvm ls-remote 里面列出来的版本号即可</span></span><br><span class="line">nvm use &lt;version&gt; <span class="comment"># 使用指定版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;node的版本实在是多，在两台mac上安装pomelo， 一台正常运行，一台运行报错，完全一样的代码，最后检查是node版本不一致，一个是9.3和9.8。后来安装nvm使用相同的9.3版后，一切正常了。&lt;/p&gt;
&lt;h3 id=&quot;nvm版本控制的安装&quot;&gt;&lt;a href=&quot;#n
      
    
    </summary>
    
      <category term="nodejs" scheme="http://blog.ku-cat.com/categories/nodejs/"/>
    
    
      <category term="node" scheme="http://blog.ku-cat.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>pomelo框架学习（三）pomelo命令行工具的安装和使用</title>
    <link href="http://blog.ku-cat.com/2018/03/31/pomelo-cli-command/"/>
    <id>http://blog.ku-cat.com/2018/03/31/pomelo-cli-command/</id>
    <published>2018-03-31T07:38:24.000Z</published>
    <updated>2018-03-31T07:53:19.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>命令行工具pomelo是Pomelo框架提供的一个小工具，该工具能够帮助开发者更便捷、更有效率地进行应用开发。该工具包括的命令支持绝大多数的应用开发操作，包括创建初始项目、启动应用、停止应用、关闭应用等。用户可以通过pomelo –help命令查询相关命令及其使用说明。</p><h3 id="命令行安装"><a href="#命令行安装" class="headerlink" title="命令行安装"></a>命令行安装</h3><p>当使用如下命令安装Pomelo的时候，pomelo会自动安装在相应的bin目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pomelo -g</span><br></pre></td></tr></table></figure><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>目前pomelo支持如下命令及选项:</p><ul><li>init: 创建一个新项目，该项目中包含创建pomelo应用的基本文件及pomelo应用的简单示例。</li><li>start: 启动应用及服务器。</li><li>list: 列出当前应用开启的所有服务器的信息，包括服务器Id、服务器类型、pid、堆使用情况、启动时长。</li><li>stop: 关闭应用及服务器或者停止指定的服务器。</li><li>kill: 强制关闭应用及服务器。</li><li>add: 运行时动态添加服务器。</li><li>masterha: 当启用masterha高可用的时候，用来启动master服务器的slave节点。</li><li>–version：列出当前使用pomelo的版本信息。</li><li>–help：列出所有pomelo支持的命令及使用说明。</li></ul><h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>根据给出的路径或文件名创建新项目，支持相对路径和绝对路径。默认情况下为当前路径，项目名称为当前文件夹名称,命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pomelo init [dirname]</span><br></pre></td></tr></table></figure><p>在创建新项目时，需要选择新项目使用的与客户端通信时使用的connector,</p><ol><li>代表 Websocket(native socket), </li><li>代表socket.io。当当前目录下有同名文件夹存在时，会提示是否覆盖，还是取消创建。</li></ol><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p>该命令用来启动Pomelo应用，命令格式如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pomelo start [-e,--env &lt;env&gt;] [-d,--directory &lt;code directory&gt;]</span><br><span class="line">             [-D,--daemon]</span><br></pre></td></tr></table></figure><ul><li>-e 用来选择启动时使用的env，如production，development，stress-test等;  </li><li>-d 用来指定项目目录；   </li><li>-D 用来开启daemon模式启动，如果开启了daemon，那么进程将转入后台运行, 所有的日志将不再打印到console上，只能通过对应的日志文件查看日志。 </li></ul><p>在0.7及以前的版本中，对于env的使用，没有使用-e选项，而是直接作为一个参数来使用的，这里需要注意一下。</p><p>用户可以在</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;project_dir&gt;/game-server/config/servers.json</span><br></pre></td></tr></table></figure><p>中为不同的服务器中添加不同参数，这些参数是node和v8支持的参数，是用来指定和影响node及v8的行为的。例如，当我们想对某一个服务器开启调试的时候，就可以在服务器配置中，增加args配置项，并在args中配置开启调试的端口等，示例如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"connector"</span>:[&#123;<span class="attr">"id"</span>:<span class="string">"connector-server-1"</span>, <span class="attr">"host"</span>:<span class="string">"127.0.0.1"</span>, <span class="attr">"port"</span>:<span class="number">4050</span>, </span><br><span class="line"><span class="attr">"clientPort"</span>:<span class="number">3050</span>, <span class="attr">"args"</span>:<span class="string">"--debug=[port]"</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>当应用启动后，该命令列出所有服务器信息。由于当执行此操作时，pomelo是作为监控管理框架的一个客户端的，在连接注册到master上的时候，需要进行身份验证。默认生成的项目中，有一个默认的用户名admin，口令也为admin，因此在不指定用户名和口令的时候，默认使用的用户名和口令均为admin，下面的stop命令和kill命令均需要使用用户名和口令验证，默认值与此处相同。应用的管理用户可以通过修改config/adminUser.json文件进行配置,具体的配置格式可以参考pomelo init生成的项目中的相关配置。</p><p>执行本命令时，还需要指定master服务器的ip和port, 这样可以是的pomelo list可以在任意地方执行。pomelo stop/kill/add等也同样需要指定master服务器的ip和port，默认使用127.0.0.1:3005作为master服务器的地址。</p><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pomelo list [-u,--username &lt;username&gt;] [-p,--password &lt;password&gt;]</span><br><span class="line">            [-h,--host &lt;master-host&gt;] [-P,--port &lt;master-port&gt;]</span><br></pre></td></tr></table></figure><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>stop用来停止当前应用，优雅地关闭应用。和kill命令不同，这种关闭首先会切断客户端与服务器的连接，然后逐一关闭所有服务器。如果指定了服务器serverId的话，则会关闭特定的服务器，而不是关闭所有的服务器。与list命令一样，需要权限验证，默认的用户名和密码均为admin,也需要指定master服务器的位置, 跟pomelo list一样，默认使用127.0.0.1:3005。</p><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pomelo stop [-u,--username &lt;username&gt;] [-p,--password &lt;password&gt;]</span><br><span class="line">            [-h,--host &lt;master-host&gt;] [-P,--port &lt;master-port&gt;]</span><br><span class="line">            [&lt;serverIds&gt;...]</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>该命令强制关闭应用。在本地进行应用开发过程中，如果遇到kill之后还有服务器进程没有关闭的情况，可以增加–force选项，强制关闭所有服务器进程。该操作相当地暴力，可能产生数据丢失等不好的影响，可以在开发调试时使用，不推荐在线上使用该命令。该命令同样也需要进行身份验证以及指定master服务器的位置，具体方式同list和stop。</p><p>该命令需在项目的根目录或game-server下使用，命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pomelo kill [-u,--username &lt;username&gt;] [-p,--password &lt;password&gt;]</span><br><span class="line">            [-h,--host &lt;master-host&gt;] [-P,--port &lt;master-port&gt;]</span><br><span class="line">            [-f,--force]</span><br></pre></td></tr></table></figure><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>该命令用来运行时动态增加服务器，与pomelo list等命令类似，pomelo add也需要身份验证以及指定master服务器的地址。具体命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pomelo add [-u,--username &lt;username&gt;] [-p,--password &lt;password&gt;]</span><br><span class="line">           [-h,--host &lt;master-host&gt;] [-P,--port &lt;master-port&gt;]</span><br><span class="line">           [&lt;server-args&gt;...]</span><br></pre></td></tr></table></figure><p>args参数是用来指定新增服务器的参数的，包括服务器类型，服务器id等， 支持一次增加一台或多台同类型的服务器，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pomelo add host=127.0.0.1 port=8000++ clientPort=9000++ frontend=true clusterCount=3 serverType=connector </span><br><span class="line">pomelo add host=127.0.0.1 port=8000 clientPort=9000 frontend=true serverType=connector id=added-connector-server masterha</span><br></pre></td></tr></table></figure><p>当启用了master服务器的高可用后，该命令用来启动master服务器的slave节点，需要在game-server/config目录下配置masterha.json。其他的命令行参数类似于pomelo start，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pomelo masterha [-d,--direcotry &lt;code directory&gt;]</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>查看当前Pomelo的版本时，可以使用如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pomelo --version</span><br></pre></td></tr></table></figure><p>查看pomelo命令行工具的帮助时，可以使用如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pomelo --help</span><br><span class="line">pomelo add --help</span><br><span class="line">pomelo start --help</span><br></pre></td></tr></table></figure><p>注:<br>一般来说在开发环境中，master服务器的地址会一直是127.0.0.1:3005,使用的管理用户的username和password直接使用默认的admin即可，这样的话，开发调试时，在执行具体的pomelo命令的时候，maser服务器的地址信息以及管理用户信息都可以省略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;命令行工具pomelo是Pomelo框架提供的一个小工具，该工具能够帮助开发者更便捷、更有效率地进行应用开发。该工具包括的命令支持绝大多数的
      
    
    </summary>
    
      <category term="pomelo" scheme="http://blog.ku-cat.com/categories/pomelo/"/>
    
    
      <category term="pomelo, nodejs" scheme="http://blog.ku-cat.com/tags/pomelo-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>pomelo框架学习（二）创建Hello World项目</title>
    <link href="http://blog.ku-cat.com/2018/03/31/pomelo-helloWorld/"/>
    <id>http://blog.ku-cat.com/2018/03/31/pomelo-helloWorld/</id>
    <published>2018-03-31T07:22:26.000Z</published>
    <updated>2018-03-31T07:35:28.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>使用pomelo的命令行工具可以快速创建一个项目，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pomelo init ./HelloWorld</span><br></pre></td></tr></table></figure><p>或者你也可以使用下面的三个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir HelloWorld</span><br><span class="line">$ cd HelloWorld</span><br><span class="line">$ pomelo init</span><br></pre></td></tr></table></figure><p>这两种创建方式是等价的，更多关于pomelo命令行使用的文档，请参阅pomelo命令行工具使用。在初始化项目的时候，用户需要选择其底层使用的通信协议，分为socket.io和websocket。</p><p>然后，进入到HelloWorld文件夹，安装依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh npm-install.sh</span><br></pre></td></tr></table></figure><p>windows用户，可以直接运行 npm-install.bat</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><p>让我们来看看一个pomelo项目的大致结构</p><p>新建立的项目结构如下图所示：<br><img src="/img/HelloWorldFolder.png" alt=""></p><p>该目录结构很清楚地展示了游戏项目的前后端分层结构，分别在各个目录下填写相关代码，即可快速开发游戏。下面对各个目录进行简要分析：</p><h4 id="game-server"><a href="#game-server" class="headerlink" title="game-server"></a>game-server</h4><p>game-server是用pomelo框架搭建的游戏服务器，以文件app.js作为入口，运行游戏的所有逻辑和功能。在接下来的开发中，所有游戏逻辑、功能、配置等都在该目录下进行。</p><ul><li><p>app子目录<br>这个目录下放置所有的游戏服务器代码的地方，用户在这里实现不同类型的服务器，添加对应的Handler，Remote等等。</p></li><li><p>config子目录<br>game-server下config包括了游戏服务器的所有配置信息。配置信息以JSON文件的格式进行定义，包含有日志、master、server等服务器的配置信息。该目录还可以进行扩展，对数据库配置信息、地图信息和数值表等信息进行定义。总而言之，这里是放着所有游戏服务器相关的配置信息的地方。</p></li><li><p>logs子目录<br>日志是项目中不可或缺的，可以对项目的运行情况进行很好的备份，也是系统运维的参考数据之一，logs存放了游戏服务器所有的日志信息。</p></li></ul><h4 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h4><p>shared存放一些前后端、game-server与web-server共用代码，由于都是javascript代码，那么对于一些工具或者算法代码，就可以前后端共用，极大地提高了代码重用性。</p><h4 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h4><p>web-server是用express 3.x框架搭建的web服务器，以文件app.js作为入口，当然开发者可以选择Nginx等其他web服务器。如果游戏的客户端不是web的话，如Android平台的话，这个目录就不是必须的了。当然，在这个例子中，我们的客户端是web，所以web服务器还是必须的。</p><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>对于我们这个例子来说，由于客户端是web，所以必须启动game-server(游戏服务器)和web-server(web服务器)</p><p>启动game-server服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd game-server</span><br><span class="line">$ pomelo start</span><br></pre></td></tr></table></figure><p>启动web-server服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd web-server</span><br><span class="line">$ node app</span><br></pre></td></tr></table></figure><p>在启动过程中可能会有端口号冲突导致启动不成功，只需在config里面修改使用的端口号即可。如果上面的启动都没有问题的话，我们就可以对我们的HelloWorld进行测试了。用浏览器(推荐使用chrome)访问 <a href="http://localhost:3001或者" target="_blank" rel="noopener">http://localhost:3001或者</a> <a href="http://127.0.0.1:3001" target="_blank" rel="noopener">http://127.0.0.1:3001</a> 即可, 点击Test Game Server，提示 game server is ok 说明运行成功</p><h3 id="查看服务器"><a href="#查看服务器" class="headerlink" title="查看服务器"></a>查看服务器</h3><p>可以使用pomelo list查看已经启动的服务器，如下图所示：</p><p><img src="/img/list_snapshot.png" alt=""></p><p>服务器状态可以查看5种状态信息：</p><ul><li>serverId：服务器的serverId，同config配置表中的id。</li><li>serverType：服务器的serverType，同config配置表中的type。</li><li>pid：服务器对应的进程pid。</li><li>heapUsed：该服务器已经使用的堆大小（单位：兆）。</li><li>uptime：该服务器启动时长（单位：分钟）。</li></ul><h3 id="关闭项目"><a href="#关闭项目" class="headerlink" title="关闭项目"></a>关闭项目</h3><p>可以使用以下两种方式关闭项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd game-server</span><br><span class="line">$ pomelo stop</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd game-server</span><br><span class="line">$ pomelo kill</span><br></pre></td></tr></table></figure></p><p>其中pomelo stop比较优雅，pomelo kill比较粗暴，安全性低，开发环境下可以使用，产品环境慎用，更详细的pomelo命令行用法请参阅pomelo命令行工具使用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里为止，我们已经成功安装了pomelo，并成功运行了HelloWorld。接下来，建议你看一下pomelo整体的一个较详细的概述。 如果你已经迫不及待地想写代码，可以去pomelo例子教程, 那里以一个chat应用为例，一步一步地向你展示如何来使用pomelo进行一个实际应用的开发，以及pomelo的一些API的使用方式等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;新建项目&quot;&gt;&lt;a href=&quot;#新建项目&quot; class=&quot;headerlink&quot; title=&quot;新建项目&quot;&gt;&lt;/a&gt;新建项目&lt;/h3&gt;&lt;p&gt;使用pomelo的命令行工具可以快速创建一个项目，命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="pomelo" scheme="http://blog.ku-cat.com/categories/pomelo/"/>
    
    
      <category term="pomelo, nodejs" scheme="http://blog.ku-cat.com/tags/pomelo-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>pomelo框架学习（一）安装pomelo</title>
    <link href="http://blog.ku-cat.com/2018/03/31/pomelo-learn/"/>
    <id>http://blog.ku-cat.com/2018/03/31/pomelo-learn/</id>
    <published>2018-03-31T06:58:43.000Z</published>
    <updated>2018-03-31T07:26:25.194Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/logo.png" alt=""></p><h3 id="一、安装pomelo"><a href="#一、安装pomelo" class="headerlink" title="一、安装pomelo"></a>一、安装pomelo</h3><p>pomelo是基于Node.js的，目前pomelo已经完全支持Windows、Linux、Mac等多种平台。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>确保你的机器可以上网,因为安装pomelo的过程需要从网上下载其依赖的包。</li><li>确保你的系统上已经要安装了Node，目前最新的Node提供了已经编译好的二进制安装包，包括Windows，Mac和Linux等平台。想省事的话，直接去这里下载对应的安装包，直接安装就好了。Node同时也提供了传统的从源码编译的方式安装，不过比起直接使用二进制的方式要麻烦。</li><li>确保你的系统中安装有python(2.5 &lt; version &lt; 3.0)以及C++的编译器。Node的源码主要由C++代码和JavaScript代码构成，但是却用gyp工具来做源码的项目管理，该工具采用Python语言写成的。对于非windows平台，一般都会预装Python以及C++编译工具；对于Windows系统，请确保你的Windows系统包含源码编译工具。在Windows平台上，Node.js采用gyp来生成Visual Studio Solution文件，最终通过VC++的编译器将其编译为二进制文件。</li><li><p>虽然pomelo是用Javascript写成，但是pomelo依赖的库中，有使用了C++语言写的扩展，因此安装pomelo的过程中会使用到C++编译器。 所以，在安装之前请确保你的Windows系统满足以下两个条件：</p><ul><li>python(2.5&lt;version&lt;3.0)。</li><li>VC++ 编译器，包含在Visual Studio 2010中（VC++ 2010 Express亦可）。对于windows8的用户，需要安装Microsoft Visual Studio C++ 2012。</li></ul></li><li><p>如果你使用的是Mac OS X系统, 则需要安装Xcode Command Line Tools或者Xcode的完整包以及make工具.</p></li></ul><h4 id="安装pomelo"><a href="#安装pomelo" class="headerlink" title="安装pomelo"></a>安装pomelo</h4><p>使用npm(node包管理工具)全局安装pomelo:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pomelo -g</span><br></pre></td></tr></table></figure><p>可以通过如下命令下载源代码的方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/NetEase/pomelo.git</span><br><span class="line">$ cd pomelo</span><br><span class="line">$ npm install -g</span><br></pre></td></tr></table></figure><p>其中-g表示全局安装，关于npm的使用问题，可以参考npm的文档，里面有详细的npm使用的介绍。如果安装过程中没有报错误，说明安装成功。</p><p>windows下安装经验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. node,vs2010 和 python(2.5&lt;v&lt;3) 都是32位或者都是64位的。</span><br><span class="line">2. 配置  PYTHON=d:\Python27\python.exe(设置成你自己的路径)。注意不是path里面,而是和path同级的，直接在全局或者当前用户下配置。</span><br><span class="line">3. 保证环境变量path里面有 %SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;</span><br><span class="line">  注： 这三个环境变量中貌似只有%SystemRoot%\system32这个环境变量有用，没具体试（没有他会报CreateProcessW找不到的错误)。</span><br><span class="line">4. 如果在命令行界面安装pomelo失败，可以在Visual Studio的命令行界面安装。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、安装pomelo&quot;&gt;&lt;a href=&quot;#一、安装pomelo&quot; class=&quot;headerlink&quot; title=&quot;一、安装pomelo&quot;&gt;&lt;/a&gt;一、安装pomelo&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="pomelo" scheme="http://blog.ku-cat.com/categories/pomelo/"/>
    
    
      <category term="pomelo,nodejs" scheme="http://blog.ku-cat.com/tags/pomelo-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌在计算机中的几种表示方法</title>
    <link href="http://blog.ku-cat.com/2018/03/31/poke/"/>
    <id>http://blog.ku-cat.com/2018/03/31/poke/</id>
    <published>2018-03-31T05:18:50.000Z</published>
    <updated>2018-04-05T02:07:32.751Z</updated>
    
    <content type="html"><![CDATA[<p>做棋牌类的游戏开发的时候，要考虑到数据存储的便捷性和数据的大小最小化，方便存储和传输，总之是越小越好。</p><p>对于扑克牌有两种表示方法：</p><ol><li>二进制存储法</li><li>map映射压缩法</li></ol><h3 id="1-二进制存储法"><a href="#1-二进制存储法" class="headerlink" title="1.二进制存储法"></a>1.二进制存储法</h3><p>首先对原始数据进行分析：扑克牌的主要属性是数值（A-K）和花色（黑、红、棉、方），A-K的数值最大是13。K 用二进制表示：1101 ，花色的表示更简单，黑桃0001、红桃 0010、梅花0011、方块 0100。也就是说数值和花色都可以用4位来表示。前4位为花色，后4位为数值，比如：黑桃A的二进制表示是黑桃 和 A 表示，即：00010001，16进制表示为11。又如：方块K的表示是 01001101，16进制表示为4D</p><p>根据上面的理论，我们可以生成52张牌，不包括大鬼和小鬼。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">sendPlist</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $plist = [];</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; <span class="number">14</span>; $i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($k = <span class="number">1</span>; $k &lt; <span class="number">5</span>; $k++) &#123;<span class="comment">//生成4个花色。例如：花色黑桃0001</span></span><br><span class="line">                $a       = $k &lt;&lt; <span class="number">4</span>;<span class="comment">//左移4位。花色黑桃左移4位，00010000</span></span><br><span class="line">                $c       = $i | $a;<span class="comment">//或操作，花色黑桃与数值A合并 00010001</span></span><br><span class="line">                $p       = dechex($c);<span class="comment">//转换成16进制：11</span></span><br><span class="line">                $plist[] = $p;<span class="comment">//保存到数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        shuffle($plist); <span class="comment">//打乱，洗牌。</span></span><br><span class="line">        <span class="keyword">return</span> $plist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>16进制牌的数据的解析成数值和花色。解析是生成的反操作。先把16进制表示的字符串转换成二进制，使用函数hexdec()转换。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$num = hexdec($hexNum);</span><br></pre></td></tr></table></figure><p>转换后的数据是二进制的。比如：黑桃K的1十六进制是1D转换成二进制是00011101。下一步操作是把这个二进制结果右移4位，得到花色0001。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$suit = $num &gt;&gt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>数值部分使用二进制和15的二进制进行与操作。00011101 &amp; 00001111结果是1101</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$n = $num &amp; <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>所有转换代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">analysisWithHex</span><span class="params">($hexNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_array($hexNum) || $hexNum==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        $num = hexdec($hexNum);</span><br><span class="line">        $suit = $num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        $n = $num &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'n'</span>=&gt;$n, <span class="string">'suit'</span>=&gt;$suit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-map映射压缩法"><a href="#2-map映射压缩法" class="headerlink" title="2.map映射压缩法"></a>2.map映射压缩法</h3><p>map映射压缩法，这种方法优点数据理更小。更方便存储和传输，相对上面的二进制法更好一些。基本原理就是用整型数值表示牌，比如：黑桃A、红桃A、梅花A、方块A、黑桃2…对就的数值为1、2、3、4、5等等。这种原理比较简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扑克牌基本数据</span></span><br><span class="line"><span class="keyword">var</span> Pokers = &#123;</span><br><span class="line"></span><br><span class="line">    table: &#123;</span><br><span class="line">        <span class="comment">//大小王</span></span><br><span class="line">        <span class="number">1</span>:  &#123;<span class="attr">symbol</span>: <span class="string">"red_joker"</span>,  <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">18</span>&#125;,</span><br><span class="line">        <span class="number">2</span>:  &#123;<span class="attr">symbol</span>: <span class="string">"black_joker"</span>,  <span class="attr">type</span>: <span class="number">3</span>, <span class="attr">num</span>: <span class="number">17</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//黑桃</span></span><br><span class="line">        <span class="number">3</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'3'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">3</span>&#125;,</span><br><span class="line">        <span class="number">4</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'4'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">4</span>&#125;,</span><br><span class="line">        <span class="number">5</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'5'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">5</span>&#125;,</span><br><span class="line">        <span class="number">6</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'6'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">6</span>&#125;,</span><br><span class="line">        <span class="number">7</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'7'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">7</span>&#125;,</span><br><span class="line">        <span class="number">8</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'8'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">8</span>&#125;,</span><br><span class="line">        <span class="number">9</span>:  &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'9'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">9</span>&#125;,</span><br><span class="line">        <span class="number">10</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'10'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">10</span>&#125;,</span><br><span class="line">        <span class="number">11</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'J'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">11</span>&#125;,</span><br><span class="line">        <span class="number">12</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'Q'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">12</span>&#125;,</span><br><span class="line">        <span class="number">13</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'K'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">13</span>&#125;,</span><br><span class="line">        <span class="number">14</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'A'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">14</span>&#125;,</span><br><span class="line">        <span class="number">15</span>: &#123;<span class="attr">suit</span>: <span class="string">"spade"</span>, <span class="attr">symbol</span>: <span class="string">'2'</span>, <span class="attr">type</span>: <span class="number">4</span>, <span class="attr">num</span>: <span class="number">16</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>使用map映射压缩法，更简单明了，而且数据量会小于上面的方法。建议使用map映射压缩法做扑克牌的表示方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做棋牌类的游戏开发的时候，要考虑到数据存储的便捷性和数据的大小最小化，方便存储和传输，总之是越小越好。&lt;/p&gt;
&lt;p&gt;对于扑克牌有两种表示方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二进制存储法&lt;/li&gt;
&lt;li&gt;map映射压缩法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-二进制存储
      
    
    </summary>
    
      <category term="php" scheme="http://blog.ku-cat.com/categories/php/"/>
    
    
      <category term="php" scheme="http://blog.ku-cat.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现socket服务</title>
    <link href="http://blog.ku-cat.com/2018/03/31/go-scoket/"/>
    <id>http://blog.ku-cat.com/2018/03/31/go-scoket/</id>
    <published>2018-03-31T04:09:23.000Z</published>
    <updated>2018-03-31T04:15:15.147Z</updated>
    
    <content type="html"><![CDATA[<p>用Go语言实现简单的sokcet服务。<br>1.串行服务端；<br>　　当客户端链接过来的时候，我们服务端可以给客户端回复特定的字符串等等。我们就以下面这段代码为例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    addr := <span class="string">"0.0.0.0:8080"</span> <span class="comment">//表示监听本地所有ip的8080端口，也可以这样写：addr := ":8080"</span></span><br><span class="line">    listener,err := net.Listen(<span class="string">"tcp"</span>,addr) <span class="comment">//使用协议是tcp，监听的地址是addr</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close() <span class="comment">//关闭监听的端口</span></span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        conn,err := listener.Accept() <span class="comment">//用conn接收链接</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(<span class="string">"Yinzhengjie\n"</span>))  <span class="comment">//通过conn的wirte方法将这些数据返回给客户端。</span></span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello Golang\n"</span>))</span><br><span class="line">        time.Sleep(time.Minute) <span class="comment">//在结束这个链接之前需要睡一分钟在结束当前循环。</span></span><br><span class="line">        conn.Close() <span class="comment">//与客户端断开连接。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.并发服务端；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle_conn</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">//这个是在处理客户端会阻塞的代码。</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"Yinzhengjie\n"</span>))  <span class="comment">//通过conn的wirte方法将这些数据返回给客户端。</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"尹正杰是一个好男孩！\n"</span>))</span><br><span class="line">    time.Sleep(time.Minute)</span><br><span class="line">    conn.Close() <span class="comment">//与客户端断开连接。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    addr := <span class="string">"0.0.0.0:8080"</span> <span class="comment">//表示监听本地所有ip的8080端口，也可以这样写：addr := ":8080"</span></span><br><span class="line">    listener,err := net.Listen(<span class="string">"tcp"</span>,addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        conn,err := listener.Accept() <span class="comment">//用conn接收链接</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> Handle_conn(conn)  <span class="comment">//开启多个协程。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Go语言实现简单的sokcet服务。&lt;br&gt;1.串行服务端；&lt;br&gt;　　当客户端链接过来的时候，我们服务端可以给客户端回复特定的字符串等等。我们就以下面这段代码为例子：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>sql语句的分组查询</title>
    <link href="http://blog.ku-cat.com/2018/03/31/sql/"/>
    <id>http://blog.ku-cat.com/2018/03/31/sql/</id>
    <published>2018-03-31T03:32:25.000Z</published>
    <updated>2018-03-31T04:06:48.679Z</updated>
    
    <content type="html"><![CDATA[<p>分组查询 按分组统计结果排序，然后再过滤统计结果的数量，然后分页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> t1.id,<span class="keyword">count</span>(*) <span class="keyword">as</span> total, t1.<span class="string">`player_num`</span></span><br><span class="line"><span class="keyword">from</span> house t1 <span class="keyword">left</span> <span class="keyword">join</span> player t2 <span class="keyword">on</span> t1.id=t2.house_id</span><br><span class="line"><span class="keyword">group</span>  <span class="keyword">by</span> t1.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total <span class="keyword">desc</span>) a <span class="keyword">where</span> total &lt; player_num;</span><br></pre></td></tr></table></figure><p>增加条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> t1.id,<span class="keyword">count</span>(*) <span class="keyword">as</span> total, t1.<span class="string">`player_num`</span>, t1.<span class="string">`union_id`</span></span><br><span class="line"><span class="keyword">from</span> house t1 <span class="keyword">left</span> <span class="keyword">join</span> player t2 <span class="keyword">on</span> t1.id=t2.house_id </span><br><span class="line"><span class="keyword">where</span> t1.union_id=<span class="number">40</span></span><br><span class="line"><span class="keyword">group</span>  <span class="keyword">by</span> t1.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total <span class="keyword">desc</span>) a </span><br><span class="line"><span class="keyword">where</span> total&lt;player_num;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分组查询 按分组统计结果排序，然后再过滤统计结果的数量，然后分页&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="sql" scheme="http://blog.ku-cat.com/categories/sql/"/>
    
    
      <category term="sql" scheme="http://blog.ku-cat.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.ku-cat.com/2018/03/31/hello-world/"/>
    <id>http://blog.ku-cat.com/2018/03/31/hello-world/</id>
    <published>2018-03-31T01:31:33.587Z</published>
    <updated>2018-03-31T01:31:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>

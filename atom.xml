<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一纸墨迹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ku-cat.com/"/>
  <updated>2018-08-25T09:03:47.524Z</updated>
  <id>http://blog.ku-cat.com/</id>
  
  <author>
    <name>Ben</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七绝/送别</title>
    <link href="http://blog.ku-cat.com/2018/08/25/poem-01/"/>
    <id>http://blog.ku-cat.com/2018/08/25/poem-01/</id>
    <published>2018-08-25T08:58:50.000Z</published>
    <updated>2018-08-25T09:03:47.524Z</updated>
    
    <content type="html"><![CDATA[<p>凄风细雨雾茫茫，</p><p>目送轻舟客影伤。</p><p>一曲箫声催怅泪，</p><p>桃花树下断人肠。</p><p><img src="img/13.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;凄风细雨雾茫茫，&lt;/p&gt;
&lt;p&gt;目送轻舟客影伤。&lt;/p&gt;
&lt;p&gt;一曲箫声催怅泪，&lt;/p&gt;
&lt;p&gt;桃花树下断人肠。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/13.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="poem" scheme="http://blog.ku-cat.com/categories/poem/"/>
    
    
      <category term="poem" scheme="http://blog.ku-cat.com/tags/poem/"/>
    
  </entry>
  
  <entry>
    <title>unity3d-player</title>
    <link href="http://blog.ku-cat.com/2018/08/09/unity3d-player/"/>
    <id>http://blog.ku-cat.com/2018/08/09/unity3d-player/</id>
    <published>2018-08-08T16:12:21.000Z</published>
    <updated>2018-08-08T16:34:54.013Z</updated>
    
    <content type="html"><![CDATA[<ol><li>控制player移动</li><li>限制player移动边界使用 <code>Mathf.clamp(rb.position, xMin, xMax);</code></li><li>多个选项放到一个类里面，游戏界面里面可以收缩这些选项</li><li>移动时让player斜 <code>Quaternion.Euler</code></li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Boundary</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span> xMin, xMax, zMin, zMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Boundary boundary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rb.position = <span class="keyword">new</span> Vector3(</span><br><span class="line">Mathf.clamp(rb.position, xMin, xMax, </span><br><span class="line"><span class="number">0.0</span>f, </span><br><span class="line">Mathf.clamp(rb.position, zMin, zMax);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;控制player移动&lt;/li&gt;
&lt;li&gt;限制player移动边界使用 &lt;code&gt;Mathf.clamp(rb.position, xMin, xMax);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多个选项放到一个类里面，游戏界面里面可以收缩这些选项&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="unity3d" scheme="http://blog.ku-cat.com/categories/unity3d/"/>
    
    
      <category term="unity3d" scheme="http://blog.ku-cat.com/tags/unity3d/"/>
    
  </entry>
  
  <entry>
    <title>golang IO COPY</title>
    <link href="http://blog.ku-cat.com/2018/08/08/go-io-copy/"/>
    <id>http://blog.ku-cat.com/2018/08/08/go-io-copy/</id>
    <published>2018-08-07T16:03:44.000Z</published>
    <updated>2018-08-25T09:06:07.771Z</updated>
    
    <content type="html"><![CDATA[<p>go的io.Copy实现代码如下。阻塞式的从src输入流读数据到dst输出流</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// If the reader has a WriteTo method, use it to do the copy.</span></span><br><span class="line"><span class="comment">// Avoids an allocation and a copy.</span></span><br><span class="line"><span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line"><span class="keyword">return</span> wt.WriteTo(dst)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span></span><br><span class="line"><span class="keyword">if</span> rt, ok := dst.(ReaderFrom); ok &#123;</span><br><span class="line"><span class="keyword">return</span> rt.ReadFrom(src)</span><br><span class="line">&#125;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">nr, er := src.Read(buf)</span><br><span class="line"><span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">nw, ew := dst.Write(buf[<span class="number">0</span>:nr])</span><br><span class="line"><span class="keyword">if</span> nw &gt; <span class="number">0</span> &#123;</span><br><span class="line">written += <span class="keyword">int64</span>(nw)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">err = ew</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nr != nw &#123;</span><br><span class="line">err = ErrShortWrite</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> er == EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">err = er</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//written 记录copy的数据大小</span></span><br><span class="line"><span class="keyword">return</span> written, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实中<code>src.(WriterTo)</code>语法：类型断言</p><a id="more"></a><p><a href="https://www.cnblogs.com/zrtqsk/p/4157350.html" target="_blank" rel="noopener">参考：https://www.cnblogs.com/zrtqsk/p/4157350.html</a></p><p>if 语句的赋值写法。以下的意思是赋值给wt和ok，如果ok为true则执行中间的语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的赋值语句返回2个值，而且后面的ok也是单变量看着有点晕。其实可以改一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok:=src.(abc); ok==<span class="literal">true</span>&#123;</span><br><span class="line"><span class="comment">//....这样看就明白多了，不过这只是个示意，代码中还是要按上面的写法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说Golang的runtime"><a href="#说说Golang的runtime" class="headerlink" title="说说Golang的runtime"></a>说说Golang的runtime</h2><p><a href="https://studygolang.com/articles/10114" target="_blank" rel="noopener">https://studygolang.com/articles/10114</a></p><p>runtime包含Go运行时的系统交互的操作，例如控制goruntine的功能。还有debug，pprof进行排查问题和运行时性能分析，tracer来抓取异常事件信息，如 goroutine的创建，加锁解锁状态，系统调用进入推出和锁定还有GC相关的事件，堆栈大小的改变以及进程的退出和开始事件等等；race进行竞态关系检查以及CGO的实现。总的来说运行时是调度器和GC，也是本文主要内容。</p><h2 id="golang-标准库分析之io-ioutil"><a href="#golang-标准库分析之io-ioutil" class="headerlink" title="golang 标准库分析之io.ioutil"></a>golang 标准库分析之io.ioutil</h2><p>golang标准库里边的io/ioutil包–也就是package io/ioutil</p><h3 id="ioutil-ReadDir"><a href="#ioutil-ReadDir" class="headerlink" title="ioutil.ReadDir"></a>ioutil.ReadDir</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ioutil.ReadDir(dirname <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数的原型是这样的 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span></span><br></pre></td></tr></table></figure><ul><li>dirname 是string类型，为文件的path</li><li>FileInfo 是切片</li></ul><p>FileInfo的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span> <span class="comment">// 文件的名称</span></span><br><span class="line">Size() <span class="keyword">int64</span> <span class="comment">// 文件的大小</span></span><br><span class="line">Mode() FileMode <span class="comment">// 文件的权限</span></span><br><span class="line">ModTime() time.Time <span class="comment">// 时间</span></span><br><span class="line">IsDir() <span class="keyword">bool</span> <span class="comment">// 是否是目录</span></span><br><span class="line">Sys() <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 基础数据源接口(can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说返回的切片可以执行FileInfo的方法，另外一个参数是什么呢？error是否成功返回！这个时候我们就能做一下实验代码是这样的一个demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io/ioutil"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dir_list, e := ioutil.ReadDir(<span class="string">"./test"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read dir error"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> dir_list &#123;</span><br><span class="line">fmt.Println(i, <span class="string">"="</span>, v.Name())</span><br><span class="line">fmt.Println(v.Name(), <span class="string">"的权限是:"</span>, v.Mode())</span><br><span class="line">fmt.Println(v.Name(), <span class="string">"文件大小:"</span>, v.Size())</span><br><span class="line">fmt.Println(v.Name(), <span class="string">"创建时间"</span>, v.ModTime())</span><br><span class="line">fmt.Println(v.Name(), <span class="string">"系统信息"</span>, v.Sys())</span><br><span class="line"><span class="keyword">if</span> v.IsDir() == <span class="literal">true</span> &#123;</span><br><span class="line">fmt.Println(v.Name(), <span class="string">"是目录"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioutil-ReadFile-filename-string"><a href="#ioutil-ReadFile-filename-string" class="headerlink" title="ioutil.ReadFile(filename string)"></a>ioutil.ReadFile(filename string)</h3><p>函数的原型是<code>func ReadFile(filename string) ([]byte, error)</code></p><p>输入的是string类型，返回的是字节型切片和一个err这个很简单我们坐下代码demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data, err := ioutil.ReadFile(<span class="string">"D:/test/widua.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read error"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioutil-ReadAll"><a href="#ioutil-ReadAll" class="headerlink" title="ioutil.ReadAll()"></a>ioutil.ReadAll()</h3><p><code>ioutil.ReadAll()</code>函数的原型是<code>func ReadAll(r io.Reader) ([]byte, error)</code>输入的是一个<code>io.Reader</code>元读取器返回的是<code>[]byte</code>字节切片和<code>error</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader := strings.NewReader(<span class="string">"hello word widuu"</span>) <span class="comment">//返回*strings.Reader</span></span><br><span class="line">fmt.Println(reflect.TypeOf(reader))</span><br><span class="line">data, _ := ioutil.ReadAll(reader)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioutil-NopCloser"><a href="#ioutil-NopCloser" class="headerlink" title="ioutil.NopCloser()"></a>ioutil.NopCloser()</h3><p><code>ioutil.NopCloser()</code>函数原型是 <code>func NopCloser(r io.Reader) io.ReadCloser</code> 还是一个Reader 然后返回的是ReadCloser接口，提供的是Close方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader := strings.NewReader(<span class="string">"hello word widuu"</span>) <span class="comment">//返回*strings.Reader</span></span><br><span class="line">r := ioutil.NopCloser(reader)</span><br><span class="line"><span class="keyword">defer</span> r.Close()</span><br><span class="line">fmt.Println(reflect.TypeOf(reader))</span><br><span class="line">data, _ := ioutil.ReadAll(reader)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="outil-TempDir"><a href="#outil-TempDir" class="headerlink" title="outil.TempDir()"></a>outil.TempDir()</h3><p>临时目录<code>ioutil.TempDir()</code>函数原型是<code>func TempDir(dir, prefix string) (name string, err error)</code>输入目录名称，前缀，返回的name是prefix+随机数字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dir, err := ioutil.TempDir(<span class="string">"D:/test"</span>, <span class="string">"tmp"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"常见临时目录失败"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dir) <span class="comment">//返回的是D:\test\tmp846626247 就是前边的prefix+随机数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="outil-TempFile"><a href="#outil-TempFile" class="headerlink" title="outil.TempFile()"></a>outil.TempFile()</h3><p>既然能创建目录就能创建文件<code>ioutil.TempFile()</code>函数原型是<code>func TempFile(dir, prefix string) (f *os.File, err error)</code>输入目录名称，前缀，返回的是文件的指针和error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, error := ioutil.TempFile(<span class="string">"D:/test"</span>, <span class="string">"tmp"</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"创建文件失败"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">file.WriteString(<span class="string">"Hello word"</span>) <span class="comment">//利用file指针的WriteString()详情见os.WriteString()</span></span><br><span class="line">filedata, _ := ioutil.ReadFile(file.Name())</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(filedata))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GO-使用YAML配置文件"><a href="#GO-使用YAML配置文件" class="headerlink" title="GO 使用YAML配置文件"></a>GO 使用YAML配置文件</h2><p>YAML是“另一种标记语言”的外语缩写（见前方参考资料原文内容）；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。</p><p>新建一个文件名为conf.yaml，键入内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/usr/local</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get gopkg.in/yaml.v2</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"gopkg.in/yaml.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> conf <span class="keyword">struct</span> &#123;</span><br><span class="line">    Enabled <span class="keyword">bool</span>   <span class="string">`yaml:"enabled"`</span></span><br><span class="line">    Path    <span class="keyword">string</span> <span class="string">`yaml:"path"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conf)</span> <span class="title">getConf</span><span class="params">()</span> *<span class="title">conf</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    yamlFile, err := ioutil.ReadFile(<span class="string">"conf.yaml"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"yamlFile.Get err   #%v "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = yaml.Unmarshal(yamlFile, c) <span class="comment">//把数据读取后写入到c中去。</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Unmarshal: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c conf</span><br><span class="line">    c.getConf()</span><br><span class="line"></span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go的io.Copy实现代码如下。阻塞式的从src输入流读数据到dst输出流&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dst Writer, src Reader)&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(written &lt;span class=&quot;keyword&quot;&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// If the reader has a WriteTo method, use it to do the copy.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Avoids an allocation and a copy.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; wt, ok := src.(WriterTo); ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wt.WriteTo(dst)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// Similarly, if the writer has a ReadFrom method, use it to do the copy.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; rt, ok := dst.(ReaderFrom); ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; rt.ReadFrom(src)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	buf := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		nr, er := src.Read(buf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; nr &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			nw, ew := dst.Write(buf[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:nr])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; nw &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				written += &lt;span class=&quot;keyword&quot;&gt;int64&lt;/span&gt;(nw)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ew != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				err = ew&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; nr != nw &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				err = ErrShortWrite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; er == EOF &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; er != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			err = er&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//written 记录copy的数据大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; written, err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实中&lt;code&gt;src.(WriterTo)&lt;/code&gt;语法：类型断言&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go语言的类型系统以及如何使用go进行封装、继承、多态等</title>
    <link href="http://blog.ku-cat.com/2018/07/22/go-interface/"/>
    <id>http://blog.ku-cat.com/2018/07/22/go-interface/</id>
    <published>2018-07-22T13:26:18.000Z</published>
    <updated>2018-07-22T14:01:05.290Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的类型系统可以是比较重要的部分了，</p><ul><li>声明新的用户定义的类型</li><li>使用方法，为类型增加新的行为</li><li>了解何时使用指针，何时使用值</li><li>通过接口实现多态</li><li>通过组合来扩展或改变类型</li><li>公开或者未公开的标识符</li></ul><p>可以使用struct创建一个结构类型。然后可以使用方法给这个结构类型增加行为，还可以使用公开或未公开的标识来摸拟公开方法和私有方法，再配合Go的接口实现多态，这些特性其实和类的概念差不多的。继承关系则可以使用结构体的提权实现。学习这些特性可以和面向对象的概念一一对应上，虽然没有class关键字，但也可以实现类的功能。</p><a id="more"></a><h2 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h2><h3 id="用户自定义类型-1"><a href="#用户自定义类型-1" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h3><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h2 id="GO语言的接口"><a href="#GO语言的接口" class="headerlink" title="GO语言的接口"></a>GO语言的接口</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言的类型系统可以是比较重要的部分了，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明新的用户定义的类型&lt;/li&gt;
&lt;li&gt;使用方法，为类型增加新的行为&lt;/li&gt;
&lt;li&gt;了解何时使用指针，何时使用值&lt;/li&gt;
&lt;li&gt;通过接口实现多态&lt;/li&gt;
&lt;li&gt;通过组合来扩展或改变类型&lt;/li&gt;
&lt;li&gt;公开或者未公开的标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用struct创建一个结构类型。然后可以使用方法给这个结构类型增加行为，还可以使用公开或未公开的标识来摸拟公开方法和私有方法，再配合Go的接口实现多态，这些特性其实和类的概念差不多的。继承关系则可以使用结构体的提权实现。学习这些特性可以和面向对象的概念一一对应上，虽然没有class关键字，但也可以实现类的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>php的后期静态绑定</title>
    <link href="http://blog.ku-cat.com/2018/07/21/php-self-static/"/>
    <id>http://blog.ku-cat.com/2018/07/21/php-self-static/</id>
    <published>2018-07-21T03:53:33.000Z</published>
    <updated>2018-07-22T13:25:46.253Z</updated>
    
    <content type="html"><![CDATA[<p>自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。</p><p>准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（<code>non-forwarding call</code>）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：<code>self::，parent::，static::</code> 以及 <code>forward_static_call()</code>。可用 <code>get_called_class()</code> 函数来得到被调用的方法所在的类名，<code>static::</code> 则指出了其范围。</p><p>该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，<code>static::</code> 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。</p><a id="more"></a><h2 id="self-的限制"><a href="#self-的限制" class="headerlink" title="self:: 的限制"></a>self:: 的限制</h2><p>使用 <code>self::</code> 或者 <code>__CLASS__</code> 对当前类的静态引用，取决于定义当前方法所在的类：</p><h3 id="Example-1-self-用法"><a href="#Example-1-self-用法" class="headerlink" title="Example #1 self:: 用法"></a>Example #1 self:: 用法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); <span class="comment">//输出A</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="后期静态绑定的用法"><a href="#后期静态绑定的用法" class="headerlink" title="后期静态绑定的用法"></a>后期静态绑定的用法</h2><p>后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 test() 时引用的类是 B 而不是 A。最终决定不引入新的关键字，而是使用已经预留的 static 关键字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who(); <span class="comment">// 后期静态绑定从这里开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); <span class="comment">//程会输出 B</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this-&gt; 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。&lt;/p&gt;
&lt;p&gt;准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（&lt;code&gt;non-forwarding call&lt;/code&gt;）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：&lt;code&gt;self::，parent::，static::&lt;/code&gt; 以及 &lt;code&gt;forward_static_call()&lt;/code&gt;。可用 &lt;code&gt;get_called_class()&lt;/code&gt; 函数来得到被调用的方法所在的类名，&lt;code&gt;static::&lt;/code&gt; 则指出了其范围。&lt;/p&gt;
&lt;p&gt;该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，&lt;code&gt;static::&lt;/code&gt; 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://blog.ku-cat.com/categories/php/"/>
    
    
      <category term="self" scheme="http://blog.ku-cat.com/tags/self/"/>
    
      <category term="static" scheme="http://blog.ku-cat.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>pomelo获取客户端的IP地址</title>
    <link href="http://blog.ku-cat.com/2018/07/20/pomelo-get-client-ip/"/>
    <id>http://blog.ku-cat.com/2018/07/20/pomelo-get-client-ip/</id>
    <published>2018-07-20T06:25:29.000Z</published>
    <updated>2018-07-20T06:38:59.691Z</updated>
    
    <content type="html"><![CDATA[<p>pomelo获取客户端的IP地址，正常的情况可以使用socket的address参数来获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.__session__.__socket__.remoteAddress.ip</span><br><span class="line"><span class="comment">//通过session的原型链访问socket,通过socket的属性获取client的IP</span></span><br></pre></td></tr></table></figure><p>如果使用nginx转发后，以上的方法就只能获得nginx所在的服务器的IP。我遇到的情况是前端wss访问nginx转发访问game服务器的ws服务。game的ws服务中始终获得的IP是<code>127.0.0.1</code>。首先配置nginx转发时配置<code>x-frorwarded-for</code>在头部信息中增加原始clinet的IP信息。最后使用以下方法获取用户的真实IP。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (session &amp;&amp; session.__session__ &amp;&amp; session.__session__.__socket__ &amp;&amp; session.__session__.__socket__.socket &amp;&amp; session.__session__.__socket__.socket.handshake) &#123;</span><br><span class="line">        <span class="keyword">var</span> handshake = session.__session__.__socket__.socket.handshake;</span><br><span class="line">        <span class="keyword">if</span> (handshake &amp;&amp; handshake.headers) &#123;</span><br><span class="line">            <span class="keyword">var</span> headers = handshake.headers;</span><br><span class="line">            <span class="keyword">var</span> realIP = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> frorwardedIP = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (headers &amp;&amp; headers[<span class="string">'x-real-ip'</span>]) &#123;</span><br><span class="line">                realIP = headers[<span class="string">'x-real-ip'</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (headers &amp;&amp; headers[<span class="string">'x-frorwarded-for'</span>]) &#123;</span><br><span class="line">                frorwardedIP = headers[<span class="string">'x-frorwarded-for'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            IP = realIP ? realIP : frorwardedIP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>session必须是前端服务器connector的handler中获取，使用CacheService保存用户的IP</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">CacheService.prototype.getUserIP = <span class="function"><span class="keyword">function</span>(<span class="params">uid</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userIP[uid];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CacheService.prototype.setUserIP = <span class="function"><span class="keyword">function</span> (<span class="params">uid, IP</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userIP[uid]= IP;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pomelo获取客户端的IP地址，正常的情况可以使用socket的address参数来获取。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="pomelo" scheme="http://blog.ku-cat.com/categories/pomelo/"/>
    
    
      <category term="pomelo" scheme="http://blog.ku-cat.com/tags/pomelo/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读</title>
    <link href="http://blog.ku-cat.com/2018/07/17/life-learn/"/>
    <id>http://blog.ku-cat.com/2018/07/17/life-learn/</id>
    <published>2018-07-17T01:02:15.000Z</published>
    <updated>2018-07-20T06:59:31.418Z</updated>
    
    <content type="html"><![CDATA[<ol><li>阅读速度</li><li>理解</li><li>注意每章节，每小段的中心内容</li><li>学习的知识点的功能及应用场景</li><li>使用思维导图组织知识点</li><li>输出</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;阅读速度&lt;/li&gt;
&lt;li&gt;理解&lt;/li&gt;
&lt;li&gt;注意每章节，每小段的中心内容&lt;/li&gt;
&lt;li&gt;学习的知识点的功能及应用场景&lt;/li&gt;
&lt;li&gt;使用思维导图组织知识点&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="life" scheme="http://blog.ku-cat.com/categories/life/"/>
    
    
      <category term="learn" scheme="http://blog.ku-cat.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>Unix地址转换函数</title>
    <link href="http://blog.ku-cat.com/2018/07/14/unix-socket-inet-aton/"/>
    <id>http://blog.ku-cat.com/2018/07/14/unix-socket-inet-aton/</id>
    <published>2018-07-14T07:27:02.000Z</published>
    <updated>2018-07-16T06:11:59.251Z</updated>
    
    <content type="html"><![CDATA[<p>地址转换函数负责ASCII字符串与网络字节的二进制值之间转换网际地址。</p><ul><li><p>函数<code>inet_ato</code>、<code>inet_addr</code>和<code>inet_ntoa</code>在点分十进制数串（例如：206.168.112.96)与长度为32位的网络字节序二进制值间转换IPv4地址。</p></li><li><p>两个较新的函数<code>inet_pton</code>和<code>inet_ntop</code>对于IPv4地址和IPv6地址都适用。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * strptr, struct in_addr *addrptr)</span></span>;</span><br><span class="line"><span class="comment">// 将strptr所指C字符串转换成一个32位的网络字节序二进制值</span></span><br><span class="line"><span class="comment">// 若成功则返回1，否则返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *strptr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个函数<code>inet_aton</code> 将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功则返回1，否则返回0。</p><blockquote><p>inet_aton 函数有一个没定入正式文档中的特征：如果addrptr指针为空， 那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。</p></blockquote><p><code>inet_addr</code>进行相同的转换，返回值为32位的网络字节二进制值。该函数存在一个问题：所有32位可能的二进制值都是有效的IP地址（从0.0.0.0到255.255.255.255），但是当出错时该函数返回的<code>INADDR_NONE</code>常值（通过是一个32位均为1的值）。这意味着点分十进制数串255.255.255.255（这是IPv4的有限广播地址，见20.2节）不能由该函数处理，因为它的二进制值被用来指示该函数失败。</p><blockquote><p>inet_addr 函数还存在一个潜在的问题：一些手册页面声明该函数出错时返回-1而不是INADDR_NONE。这样在对该函数的返回值（一个无符号的值）和一个负常值（-1）进行比较时可能会发生问题，具体取决于C编译器。</p></blockquote><p><code>inet_ntoa</code> 函数将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是不可重入的。</p><h3 id="inet-pton-和-inet-ntop函数"><a href="#inet-pton-和-inet-ntop函数" class="headerlink" title="inet_pton 和 inet_ntop函数"></a><code>inet_pton</code> 和 <code>inet_ntop</code>函数</h3><p>函数应用IPv4和IPv6地址，函数中的p和n分别代表表达(presentaion)和数值(numeric)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span>;</span><br><span class="line"><span class="comment">//返回 ： 若成功则为1，若输入不是有效的表达格式则为0.若出错则为-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addrptr, <span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向结果的指针，若出错则为null</span></span><br></pre></td></tr></table></figure><p>这两个函数的family参数既可以是<code>AF_INET</code>, 也可以是<code>AF_INET6</code>, 如果以不被支持的地址族作为family参数，这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;地址转换函数负责ASCII字符串与网络字节的二进制值之间转换网际地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数&lt;code&gt;inet_ato&lt;/code&gt;、&lt;code&gt;inet_addr&lt;/code&gt;和&lt;code&gt;inet_ntoa&lt;/code&gt;在点分十进制数串（例如：206.
      
    
    </summary>
    
      <category term="c/c++" scheme="http://blog.ku-cat.com/categories/c-c/"/>
    
    
      <category term="c" scheme="http://blog.ku-cat.com/tags/c/"/>
    
      <category term="unix" scheme="http://blog.ku-cat.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Unix字节操作函数 bzero,bcopy,bcmp,memset,memcpy,memcmp</title>
    <link href="http://blog.ku-cat.com/2018/07/14/unix-socket-byte-fun/"/>
    <id>http://blog.ku-cat.com/2018/07/14/unix-socket-byte-fun/</id>
    <published>2018-07-14T06:45:01.000Z</published>
    <updated>2018-07-14T07:14:27.579Z</updated>
    
    <content type="html"><![CDATA[<p>名字以b(表示字节)开阔大的第一组函数起源于4.2BSD，几乎所有现今支持套接字函数的系统仍然提供他们这些函数。名字以mem(表示内存) 开头的第二组函数起源于ANSI C标准，支持ANSI C函数库的所有系统都提供它他。</p><h3 id="4-2BSD-函数"><a href="#4-2BSD-函数" class="headerlink" title="4.2BSD 函数"></a>4.2BSD 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">void</span> * dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * ptrl, <span class="keyword">const</span> <span class="keyword">void</span> * ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>const 限定词，在这里的作用表示，所限定的指针src、ptrl和ptr2所指的内容不会被函数更改。换句话说，函数只是读而不修改由const指针所指的内存单元。</p></blockquote><p>bzero把目标字节串中指定数目的字节置为0.我们经常使用该函数来把一个套接字地址结构初始化为0。bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节串，若相同则返回值为0， 否则返回值为非0.</p><h3 id="ANSI-C函数"><a href="#ANSI-C函数" class="headerlink" title="ANSI C函数"></a>ANSI C函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptrl, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// 返回：若相等则为0，否则为&lt;0或&gt;0 第一个字节大于第二个字节返回值大于0，否则小于0.</span></span><br></pre></td></tr></table></figure><p>memset把目标字节串指定数目的字节置为值c。memcpy类似bcopy，不过两个指针参数的顺序是相反的。当源字节串与目标字节串重叠时，bcopy能够正确处理，但是memcpy的操作结果却不可知。这种情况下必须改用ANSI C的memmove函数。</p><blockquote><p>记住memcpy两个指针参数顺序的方法之一是记着他们是按照与c中的赋值语句相同的顺序从左到右书写的：dest = src;</p></blockquote><blockquote><p>记住memset最后两个参数顺序的方法之一是认识到所有ANSI C的memxxx函数都需要一个长度参数，而且它总是最后一个参数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;名字以b(表示字节)开阔大的第一组函数起源于4.2BSD，几乎所有现今支持套接字函数的系统仍然提供他们这些函数。名字以mem(表示内存) 开头的第二组函数起源于ANSI C标准，支持ANSI C函数库的所有系统都提供它他。&lt;/p&gt;
&lt;h3 id=&quot;4-2BSD-函数&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="c/c++" scheme="http://blog.ku-cat.com/categories/c-c/"/>
    
    
      <category term="c" scheme="http://blog.ku-cat.com/tags/c/"/>
    
      <category term="unix" scheme="http://blog.ku-cat.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Unix字节排序函数</title>
    <link href="http://blog.ku-cat.com/2018/07/14/unix-socket-base01/"/>
    <id>http://blog.ku-cat.com/2018/07/14/unix-socket-base01/</id>
    <published>2018-07-14T05:41:11.000Z</published>
    <updated>2018-07-14T06:41:14.185Z</updated>
    
    <content type="html"><![CDATA[<p>一个16位整数，它由2个字节组成。内存中存储这两个字节有两种方法：</p><ul><li>一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；</li><li>另一种方法是将高序字节存储在起始地址，这称大端（big-endian）字节序；</li></ul><blockquote><p>术语“大端”和“小端”表示多个字节值的哪一端（大端或小端）存储在该值的起始地址。</p></blockquote><a id="more"></a><p>两个字节序没有标准，有的系统用的是大端，有的则用的是小端。可以通过下面的程序输出主机字节序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">short</span> s;</span><br><span class="line"><span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; un;</span><br><span class="line"></span><br><span class="line">un.s = <span class="number">0x0102</span>; <span class="comment">//短整数变量存入2个字节值0x0102 。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: "</span>, CPU_VENDOR_OS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>) <span class="comment">//检查起始地址的值 un.c[0]==1,表示大的在起始端了。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big-endian \n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"little-endian \n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"unknown \n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(short) = %d \n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在一个短的整数变量存放2个字节的值0x0102,然后查看他的两个连续字节c[0]和c[1]来确定字节序</p><p>网络协议必须指定一个网络字节序（network byte order)</p><h3 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue);</span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> host32bitvalue);<span class="comment">//均返回：网络字节序的值</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue);<span class="comment">//均返回：主机字节序的值</span></span><br></pre></td></tr></table></figure><p>以上函数的名字中，h代表host， n代表network， s代表short，l代表long。short和long这两个称谓是出自4.2BSD的Digital VAX实现的历史产物。如今我们应该把s视为一个16位的值（例如TCP或UDP端口号），把1视为一个32位的值。事实上即使在64位的Digital Alpha中，尽管长整数占用64位，htonl和ntohl函数操作的仍然是32位的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个16位整数，它由2个字节组成。内存中存储这两个字节有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；&lt;/li&gt;
&lt;li&gt;另一种方法是将高序字节存储在起始地址，这称大端（big-endian）字节序；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;术语“大端”和“小端”表示多个字节值的哪一端（大端或小端）存储在该值的起始地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://blog.ku-cat.com/categories/c-c/"/>
    
    
      <category term="c" scheme="http://blog.ku-cat.com/tags/c/"/>
    
      <category term="unix" scheme="http://blog.ku-cat.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>read、readn、writen和readline函数</title>
    <link href="http://blog.ku-cat.com/2018/07/10/c-readn-writen-readline/"/>
    <id>http://blog.ku-cat.com/2018/07/10/c-readn-writen-readline/</id>
    <published>2018-07-10T08:03:17.000Z</published>
    <updated>2018-07-14T05:40:24.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="readn、writen和readline函数"><a href="#readn、writen和readline函数" class="headerlink" title="readn、writen和readline函数"></a>readn、writen和readline函数</h1><p>字节流套接字（例如TCP套接字）上的read和write函数所表现的行为不同于通常的文件I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少， 然而这不是出错的状态。这个现象的原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的是调用者再次调用read或write函数，以输入或输出剩余的字节。有些版本的Unix在往一个管道中写多于4096字节的数据时也会表现出这样的行为。这个现象在read一个字节流套接字时很常，但是在write一个字节流套接字时只能在该套接字为非阻塞的前提下才出现。尽管如此，为预防万一，不让实现返回一个不足的字节计数值，我们总是改为调用writen函数来取代write函数。</p><p>我们提供的以下3个函数是每当我们读或写一个字节流套接字时总要使用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="comment">// 返回值：成功返回读取的字节数，出错返回-1并设置errno，</span></span><br><span class="line"><span class="comment">// 如果在调read之前已到达文件末尾，则这次read返回0</span></span><br><span class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fileds, <span class="keyword">void</span> * fuff, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> writeent(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> readline(<span class="keyword">int</span> filedes, <span class="keyword">void</span> * buff, <span class="keyword">size_t</span> maxlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 均返回读或写的字节数，若出错则为-1</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="read-函数相关内容："><a href="#read-函数相关内容：" class="headerlink" title="read 函数相关内容："></a>read 函数相关内容：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。</p><p>fread就是通过read来实现的，fread是C语言的库，而read是系统调用。</p><p>但是差别在read每次读的数据是调用者要求的大小，比如调用要求读取10个字节数据，read就会读10个字节数据到数组中，而fread不一样，为了加快读的速度，fread每次都会读比要求更多的数据，然后放到缓冲区中，这样下次再读数据只需要到缓冲区中去取就可以了。</p><p>fread每次会读取一个缓冲区大小的数据，32位下一般是4096个字节，相当于调用了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(fd,buf,<span class="number">4096</span>)</span><br></pre></td></tr></table></figure><p>比如需要读取512个字节数据，分4次读取，调用read就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)</span><br><span class="line">read(fd,buf,<span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>一共有4次系统调用</p><p>而fread一次就读取了4096字节放到缓冲区了，所以省事了</p><p>比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是<code>ssize_t</code>，表示有符号的<code>size_t</code>，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。</p><p>read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如：</p><ul><li><p>读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。</p></li><li><p>从终端设备读，通常以行为单位，读到换行符就返回了。</p></li><li><p>从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，后面socket编程部分会详细讲解。</p></li></ul><h3 id="write函数向打开的设备或文件中写数据"><a href="#write函数向打开的设备或文件中写数据" class="headerlink" title="write函数向打开的设备或文件中写数据"></a>write函数向打开的设备或文件中写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  ssize_t write(int fd, const void *buf, size_t count); 返回值：成功返回写入的字节数，出错返回-1并设置errno</span></span></span><br></pre></td></tr></table></figure><p>写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定。</p><p>读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。从终端设备或网络读则不一定，<strong>如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。</strong>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p><h3 id="readn函数的实现"><a href="#readn函数的实现" class="headerlink" title="readn函数的实现"></a>readn函数的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> n);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line">ptr = vptr;</span><br><span class="line"></span><br><span class="line">nleft = n;</span><br><span class="line"><span class="keyword">while</span>(nleft&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTER) <span class="comment">// 中断处理</span></span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">nleft -= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n -nleft); <span class="comment">// return &gt;= 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">##<span class="meta"># writen函数的实现：往一个描述符写n字节。</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * vptr, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (nwritten = write(fd, ptr, nleft))&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) <span class="comment">// 中断处理</span></span><br><span class="line">nwritten = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readline函数的实现：从一个描述符读文本行，一次一个字节。"><a href="#readline函数的实现：从一个描述符读文本行，一次一个字节。" class="headerlink" title="readline函数的实现：从一个描述符读文本行，一次一个字节。"></a>readline函数的实现：从一个描述符读文本行，一次一个字节。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readline(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> maxlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n, rc;</span><br><span class="line"><span class="keyword">char</span> c, * ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>, n&lt; maxlen; n++)&#123;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((rc=read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)&#123;</span><br><span class="line">*ptr++ = c; <span class="comment">//把读到的c存入ptr中去</span></span><br><span class="line"><span class="keyword">if</span>( c == <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// newline is stored, like fgets() 换行存储，类型fgets()函数</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>(n<span class="number">-1</span>); <span class="comment">// EOF, n-1 bytes were read 读到结尾了。读取了n-1个字节。</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>); <span class="comment">//error ,errno set by read()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述三个函数查找EINTER错误（表示系统调用被一个捕获的信号中断）如果发生该错误则继续进行读或写操作。既然这些函数的作用是避免让调用者来处理不足的字节计数值，那么我们就地处理该错误，而不是强迫调用者再次调用readn或writen函数。</p><blockquote><p>注意，这个readline函数每读一个字节的数据就调用一次系统的read函数。这是非常低效率的， 为些我们特意在代码中注明“PAINFULLY SLOW(极慢的)“。 当面临从某个套接字读入文本行这一需求时，改用标准I/O函数库（称为stdio)相当诱人。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;readn、writen和readline函数&quot;&gt;&lt;a href=&quot;#readn、writen和readline函数&quot; class=&quot;headerlink&quot; title=&quot;readn、writen和readline函数&quot;&gt;&lt;/a&gt;readn、writen和readline函数&lt;/h1&gt;&lt;p&gt;字节流套接字（例如TCP套接字）上的read和write函数所表现的行为不同于通常的文件I/O。字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少， 然而这不是出错的状态。这个现象的原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的是调用者再次调用read或write函数，以输入或输出剩余的字节。有些版本的Unix在往一个管道中写多于4096字节的数据时也会表现出这样的行为。这个现象在read一个字节流套接字时很常，但是在write一个字节流套接字时只能在该套接字为非阻塞的前提下才出现。尽管如此，为预防万一，不让实现返回一个不足的字节计数值，我们总是改为调用writen函数来取代write函数。&lt;/p&gt;
&lt;p&gt;我们提供的以下3个函数是每当我们读或写一个字节流套接字时总要使用的函数。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;unp.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; read(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回值：成功返回读取的字节数，出错返回-1并设置errno，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果在调read之前已到达文件末尾，则这次read返回0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; readn(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fileds, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * fuff, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; nbytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; writeent(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; filedes, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buff, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; nbytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; readline(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; filedes, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * buff, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; maxlen);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 均返回读或写的字节数，若出错则为-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="c/c++" scheme="http://blog.ku-cat.com/categories/c-c/"/>
    
    
      <category term="c" scheme="http://blog.ku-cat.com/tags/c/"/>
    
      <category term="unix" scheme="http://blog.ku-cat.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>荀子.劝学篇</title>
    <link href="http://blog.ku-cat.com/2018/07/05/ben-01/"/>
    <id>http://blog.ku-cat.com/2018/07/05/ben-01/</id>
    <published>2018-07-05T06:42:23.000Z</published>
    <updated>2018-07-20T06:59:09.828Z</updated>
    
    <content type="html"><![CDATA[<p>吾尝终日而思矣,不如须臾之所学也.吾尝跂而望矣,不如登高之博见也.登高而招,臂非加长也,而见者远；顺风而呼,声非加疾也,而闻者彰.假舆马者,非利足也,而致千里；假舟楫者,非能水也,而绝江河.君子生非异也,善假于物也.</p><a id="more"></a><p>荀子.劝学篇<br>我曾经整天思索,（却）不如片刻学到的知识（多）；我曾经踮起脚远望,（却）不如登到高处看得广阔.登到高处招手,手臂并没有加长,可是别人在远处也看见；顺着风呼叫,声音没有比原来加大,可是听的人听得很清楚.借助车马的人,并不是脚走得快,却可以行千里,借助船只的人,并不是能游水,却可以横渡江河.君子的本性跟一般人没什么不同,（只是君子）善于借助外物罢了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吾尝终日而思矣,不如须臾之所学也.吾尝跂而望矣,不如登高之博见也.登高而招,臂非加长也,而见者远；顺风而呼,声非加疾也,而闻者彰.假舆马者,非利足也,而致千里；假舟楫者,非能水也,而绝江河.君子生非异也,善假于物也.&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://blog.ku-cat.com/categories/life/"/>
    
    
      <category term="learn" scheme="http://blog.ku-cat.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>make命令</title>
    <link href="http://blog.ku-cat.com/2018/07/03/makefile/"/>
    <id>http://blog.ku-cat.com/2018/07/03/makefile/</id>
    <published>2018-07-03T00:51:59.000Z</published>
    <updated>2018-07-24T06:05:48.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile文件的格式"><a href="#Makefile文件的格式" class="headerlink" title="Makefile文件的格式"></a>Makefile文件的格式</h2><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">转载</a></p><p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</p><p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><p>本文介绍Make命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是Isaac Schlueter的<a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener">《Makefile文件教程》</a>和<a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">《GNU Make手册》</a>。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。</p><p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="comment"># 没有目标会执行第一个目标</span></span><br></pre></td></tr></table></figure><p>上面代码执行Makefile文件的第一个目标。</p><h3 id="前置条件-prerequisites"><a href="#前置条件-prerequisites" class="headerlink" title="前置条件 prerequisites"></a>前置条件 prerequisites</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">result.txt: source.txt</span></span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">source.txt:</span></span><br><span class="line">    echo <span class="string">"this is the source"</span> &gt; source.txt</span><br></pre></td></tr></table></figure><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure><p>上面命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">source: file1 file2 file3</span></span><br></pre></td></tr></table></figure><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make source</span><br></pre></td></tr></table></figure><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure><h3 id="命令（commands）"><a href="#命令（commands）" class="headerlink" title="命令（commands）"></a>命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量<code>.RECIPEPREFIX</code>声明。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure><p>上面代码用<code>.RECIPEPREFIX</code>指定，大于号<code>&gt;</code>替代<code>tab</code>键。所以，每一行命令的起首变成了<code>&gt;</code>号，而不是<code>tab</code>键。</p><p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-lost:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure><p>上面代码执行后<code>make var-lost</code>，取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用<strong>分号分隔</strong>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure><p>另一个解决办法是在换行符前加反斜杠转义。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; </span><br><span class="line">    echo <span class="string">"foo=[$$foo]"</span></span><br></pre></td></tr></table></figure><h2 id="Makefile文件的语法"><a href="#Makefile文件的语法" class="headerlink" title="Makefile文件的语法"></a>Makefile文件的语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>井号（#）在Makefile中表示注释。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="section">result.txt: source.txt</span></span><br><span class="line">    <span class="comment"># 这是注释</span></span><br><span class="line">    cp source.txt result.txt <span class="comment"># 这也是注释</span></span><br></pre></td></tr></table></figure><h3 id="回声（echoing）"><a href="#回声（echoing）" class="headerlink" title="回声（echoing）"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>执行上面的规则，会得到下面的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make test</span><br><span class="line"># 这是测试</span><br></pre></td></tr></table></figure><p>在命令的前面加上@，就可以关闭回声。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br></pre></td></tr></table></figure><p>现在再执行make test，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br><span class="line">    @echo TODO</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号<code>*</code>、问号<code>？</code>和<code>...</code> 。比如， <code>*.o</code> 表示所有后缀名为o的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">        rm -f *.o</span><br></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure><p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p><h3 id="变量和赋值符"><a href="#变量和赋值符" class="headerlink" title="变量和赋值符"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line">test:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p><p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @echo $$HOME</span><br></pre></td></tr></table></figure><p>有时，变量的值可能指向另一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看StackOverflow。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value <span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line">VARIABLE := value <span class="comment"># 在定义时扩展。</span></span><br><span class="line">VARIABLE ?= value <span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line">VARIABLE += value <span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h3 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，<code>$(CC)</code> 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">output:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o output input.c</span><br></pre></td></tr></table></figure><h3 id="自动变量（Automatic-Variables）"><a href="#自动变量（Automatic-Variables）" class="headerlink" title="自动变量（Automatic Variables）"></a>自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>….</p><h2 id="Makefile-的实例"><a href="#Makefile-的实例" class="headerlink" title="Makefile 的实例"></a>Makefile 的实例</h2><h3 id="执行多个目标"><a href="#执行多个目标" class="headerlink" title="执行多个目标"></a>执行多个目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Makefile文件的格式&quot;&gt;&lt;a href=&quot;#Makefile文件的格式&quot; class=&quot;headerlink&quot; title=&quot;Makefile文件的格式&quot;&gt;&lt;/a&gt;Makefile文件的格式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/02/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。&lt;/p&gt;
&lt;p&gt;Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。&lt;/p&gt;
&lt;p&gt;本文介绍Make命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是Isaac Schlueter的&lt;a href=&quot;https://gist.github.com/isaacs/62a2d1825d04437c6f08&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Makefile文件教程》&lt;/a&gt;和&lt;a href=&quot;https://www.gnu.org/software/make/manual/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《GNU Make手册》&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="make" scheme="http://blog.ku-cat.com/tags/make/"/>
    
      <category term="makefile" scheme="http://blog.ku-cat.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>go语言的gob包的介绍与使用</title>
    <link href="http://blog.ku-cat.com/2018/06/29/go-gob/"/>
    <id>http://blog.ku-cat.com/2018/06/29/go-gob/</id>
    <published>2018-06-29T01:30:04.000Z</published>
    <updated>2018-07-20T06:59:22.314Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的gob包主要的功能是对go的数据进行序列化与反序列化操作。我们在其它语言使用json或是xml的方式对数据进行序列化操作，go语言有自己的序列化和反序列包，就是gob了。</p><p>gob是Golang自带的一个数据结构序列化的编码与解码工具。</p><p>编码使用Encoder方法，解码使用Decode方法，最典型的应用场景就是RPC通信。</p><a id="more"></a><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p>func Register</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>在其内部类型名称下注册记录类型，由该类型的值标识。</p><p>func NewDecoder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoder</span></span></span><br></pre></td></tr></table></figure><p>func NewEncoder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span></span><br></pre></td></tr></table></figure><p>func (*Encoder) Encode</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoder)</span> <span class="title">Encode</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>使用的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/gob"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Z <span class="keyword">int</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y *<span class="keyword">int32</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fout bytes.Buffer        </span><br><span class="line">    enc := gob.NewEncoder(&amp;fout) <span class="comment">//新的编码器</span></span><br><span class="line">    </span><br><span class="line">    err := enc.Encode(P&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"Pythagoras"</span>&#125;)<span class="comment">//编码结构体和数据</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"encode error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ioutil.WriteFile(<span class="string">"vt.dat"</span>, fout.Bytes(), <span class="number">0644</span>)<span class="comment">//写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取并且解码</span></span><br><span class="line">    fin,err := os.Open(<span class="string">"vt.dat"</span>)<span class="comment">//读取数据</span></span><br><span class="line">    dec := gob.NewDecoder(fin)<span class="comment">//解码数据</span></span><br><span class="line">    <span class="keyword">var</span> q Q</span><br><span class="line">    err = dec.Decode(&amp;q)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"decode error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%q: &#123;%d,%d&#125;\n"</span>, q.Name, *q.X, *q.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Register和RegisterName"><a href="#Register和RegisterName" class="headerlink" title="Register和RegisterName"></a>Register和RegisterName</h2><p>这两个方法是当编解码中有一个字段是interface{}的时候需要对interface{}的可能产生的类型进行注册。具体就看一下下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y, Z <span class="keyword">int</span></span><br><span class="line">Name    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Q <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y *<span class="keyword">int32</span></span><br><span class="line">Name <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Inner <span class="keyword">struct</span> &#123;</span><br><span class="line">Test <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> network bytes.Buffer        <span class="comment">// Stand-in for a network connection</span></span><br><span class="line">enc := gob.NewEncoder(&amp;network) <span class="comment">// Will write to network.</span></span><br><span class="line">dec := gob.NewDecoder(&amp;network) <span class="comment">// Will read from network.</span></span><br><span class="line"></span><br><span class="line">gob.Register(Inner&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode (send) the value.</span></span><br><span class="line">inner := Inner&#123;<span class="number">1</span>&#125;</span><br><span class="line">err := enc.Encode(P&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, inner&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"encode error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decode (receive) the value.</span></span><br><span class="line"><span class="keyword">var</span> q Q</span><br><span class="line">err = dec.Decode(&amp;q)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"decode error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line">fmt.Printf(<span class="string">"%q: &#123;%d,%d&#125;\n"</span>, q.Name, *q.X, *q.Y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了gob.Register(Inner{})告诉系统：所有的Interface是有可能为Inner结构的<br>在这个例子中，如果你注释了gob.Register, 系统会报错。</p><p>RegisterName是和Register一样的效果，只是在Register的同时也为这个类型附上一个别名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go语言的gob包主要的功能是对go的数据进行序列化与反序列化操作。我们在其它语言使用json或是xml的方式对数据进行序列化操作，go语言有自己的序列化和反序列包，就是gob了。&lt;/p&gt;
&lt;p&gt;gob是Golang自带的一个数据结构序列化的编码与解码工具。&lt;/p&gt;
&lt;p&gt;编码使用Encoder方法，解码使用Decode方法，最典型的应用场景就是RPC通信。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
      <category term="gob" scheme="http://blog.ku-cat.com/tags/gob/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中Socket通信TCP服务端</title>
    <link href="http://blog.ku-cat.com/2018/06/29/go-net/"/>
    <id>http://blog.ku-cat.com/2018/06/29/go-net/</id>
    <published>2018-06-29T00:42:47.000Z</published>
    <updated>2018-07-20T07:27:45.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="package-net"><a href="#package-net" class="headerlink" title="package net"></a>package net</h2><p>import “net”</p><p>net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。<br>虽然本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和类似的Dial和Listen函数。</p><p>Dial函数和服务端建立连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"google.com:80"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(conn, <span class="string">"GET / HTTP/1.0\r\n\r\n"</span>)</span><br><span class="line">status, err := bufio.NewReader(conn).ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>Listen函数创建的服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := ln.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Go语言中Socket通信TCP服务端"><a href="#Go语言中Socket通信TCP服务端" class="headerlink" title="Go语言中Socket通信TCP服务端"></a>Go语言中Socket通信TCP服务端</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><ol><li>定义远程IP地址。使用net.ResolveTCPAddr()方法，定义一个TCP地址，做为本机监听地址。</li><li>使用net.ListenTCP(“tcp”,localAddress)方法开始监听，并返回tcpListener对像。</li><li>使用tcpListener.AcceptTCP方法进行接受连接。返回：net.TCPConn对像。</li><li>对net.TCPConn对像进行读写操作。</li><li>关闭连接。</li></ol><p>　　</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">localAddress, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"127.0.0.1:8080"</span>) <span class="comment">//定义一个本机IP和端口。</span></span><br><span class="line"><span class="keyword">var</span> tcpListener, err = net.ListenTCP(<span class="string">"tcp"</span>, localAddress)       <span class="comment">//在刚定义好的地址上进监听请求。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"监听出错："</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//担心return之前忘记关闭连接，因此在defer中先约定好关它。</span></span><br><span class="line">tcpListener.Close()</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"正在等待连接..."</span>)</span><br><span class="line"><span class="keyword">var</span> conn, err2 = tcpListener.AcceptTCP() <span class="comment">//接受连接。</span></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"接受连接失败："</span>, err2)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> remoteAddr = conn.RemoteAddr() <span class="comment">//获取连接到的对像的IP地址。</span></span><br><span class="line">fmt.Println(<span class="string">"接受到一个连接："</span>, remoteAddr)</span><br><span class="line">fmt.Println(<span class="string">"正在读取消息..."</span>)</span><br><span class="line"><span class="keyword">var</span> bys, _ = ioutil.ReadAll(conn) <span class="comment">//读取对方发来的内容。</span></span><br><span class="line">fmt.Println(<span class="string">"接收到客户端的消息："</span>, <span class="keyword">string</span>(bys))</span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello, Nice to meet you, my name is SongXingzhu"</span>)) <span class="comment">//尝试发送消息。</span></span><br><span class="line">conn.Close()                                                          <span class="comment">//关闭连接。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:/Application/Go/bin/<span class="keyword">go</span>.exe build -i [D:/Projects/GoPath/source/demo/socket/server]</span><br><span class="line">成功: 进程退出代码 <span class="number">0.</span></span><br><span class="line">D:/Projects/GoPath/source/demo/socket/server/server.exe  [D:/Projects/GoPath/source/demo/socket/server]</span><br><span class="line">正在等待连接...</span><br><span class="line">接受到一个连接： <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">47203</span></span><br><span class="line">正在读取消息...</span><br><span class="line">接收到客户端的消息： GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,*<span class="comment">/*;q=0.8</span></span><br><span class="line"><span class="comment">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate, sdch</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成功: 进程退出代码 0.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;package-net&quot;&gt;&lt;a href=&quot;#package-net&quot; class=&quot;headerlink&quot; title=&quot;package net&quot;&gt;&lt;/a&gt;package net&lt;/h2&gt;&lt;p&gt;import “net”&lt;/p&gt;
&lt;p&gt;net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。&lt;br&gt;虽然本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和类似的Dial和Listen函数。&lt;/p&gt;
&lt;p&gt;Dial函数和服务端建立连接：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn, err := net.Dial(&lt;span class=&quot;string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;google.com:80&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// handle error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Fprintf(conn, &lt;span class=&quot;string&quot;&gt;&quot;GET / HTTP/1.0\r\n\r\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;status, err := bufio.NewReader(conn).ReadString(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Listen函数创建的服务端：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ln, err := net.Listen(&lt;span class=&quot;string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;:8080&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// handle error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	conn, err := ln.Accept()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// handle error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; handleConnection(conn)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
      <category term="net" scheme="http://blog.ku-cat.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透-ngrok原理浅析</title>
    <link href="http://blog.ku-cat.com/2018/06/28/ngrok-desc/"/>
    <id>http://blog.ku-cat.com/2018/06/28/ngrok-desc/</id>
    <published>2018-06-28T06:53:58.000Z</published>
    <updated>2018-07-20T06:43:59.848Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/sunansheng/article/details/48372149" target="_blank" rel="noopener">转载地址:https://blog.csdn.net/sunansheng/article/details/48372149</a></p><p>家里服务器的访问使用的就是ngrok服务：ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost”，这个诠释有两层含义：</p><ol><li>可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。</li><li>支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。</li></ol><p>因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。</p><p>今天我们就来简单分析一下这款强大工具的实现原理。ngrok本身是用go语言实现的，需要go 1.1以上版本编译。ngrok官方代码最新版为1.7，作者似乎已经完成了ngrok 2.0版本，但不知为何迟迟不放出最新代码。因此这里我们就以ngrok 1.7版本源码作为原理分析的基础。</p><a id="more"></a><h2 id="一、ngrok-tunnel与ngrok部署"><a href="#一、ngrok-tunnel与ngrok部署" class="headerlink" title="一、ngrok tunnel与ngrok部署"></a>一、ngrok tunnel与ngrok部署</h2><p>网络tunnel（隧道）对多数人都是很”神秘“的概念，tunnel种类很多，没有标准定义，我了解的也不多（日常工作较少涉及），这里也就不 深入了。在《HTTP权威指南》中有关于HTTP tunnel（http上承载非web流量）和SSL tunnel的说明，但ngrok中的tunnel又与这些有所不同。</p><p>ngrok实现了一个tcp之上的端到端的tunnel，两端的程序在ngrok实现的Tunnel内透明的进行数据交互。</p><p><img src="/img/ngrok-tunnel.png" alt="tunnel"></p><p>ngrok分为client端(ngrok)和服务端(ngrokd)，实际使用中的部署如下：</p><p><img src="/img/ngrok-deployment.png" alt="tunnel"></p><p>内网服务程序可以与ngrok client部署在同一主机，也可以部署在内网可达的其他主机上。ngrok和ngrokd会为建立与public client间的专用通道（tunnel）。</p><h3 id="二、ngrok开发调试环境搭建"><a href="#二、ngrok开发调试环境搭建" class="headerlink" title="二、ngrok开发调试环境搭建"></a>二、ngrok开发调试环境搭建</h3><p>在学习ngrok代码或试验ngrok功能的时候，我们可能需要搭建一个ngrok的开发调试环境。ngrok作者在ngrok developer guide中给出了步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; git clone https://github.com/inconshreveable/ngrok</span><br><span class="line">$&gt; cd ngrok</span><br><span class="line">$&gt; make client</span><br><span class="line">$&gt; make server</span><br></pre></td></tr></table></figure><p><code>make client</code>和<code>make server</code>执行后，会建构出ngrok和ngrokd的debug版本。如果要得到release版本，请使用<code>make release-client</code>和<code>make release-server</code>。debug版本与release版本的区别在于debug版本不打包 assets下的资源文件，执行时通过文件系统访问。</p><p>修改/etc/hosts文件，添加两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 ngrok.me</span><br><span class="line">127.0.0.1 test.ngrok.me</span><br></pre></td></tr></table></figure><p>创建客户端配置文件debug.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server_addr: ngrok.me:4443</span><br><span class="line">trust_host_root_certs: false</span><br><span class="line">tunnels:</span><br><span class="line">      test:</span><br><span class="line">        proto:</span><br><span class="line">           http: 8080</span><br></pre></td></tr></table></figure><p>不过要想让ngrok与ngrokd顺利建立通信，我们还得制作数字证书(自签发)，源码中自带的证书是无法使用的，证书制作方法可参见<a href="http://tonybai.com/2015/03/14/selfhost-ngrok-service/" target="_blank" rel="noopener">《搭建自 己的ngrok服务》</a>一文，相关原理可参考<a href="http://tonybai.com/2015/04/30/go-and-https/" target="_blank" rel="noopener">《Go和HTTPS》</a>一文，这里就不赘述了。</p><p>直接使用的是release版本(放在bin/release下)，这样在执行命令时可以少传入几个参数：</p><p>启动服务端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&gt; sudo ./bin/release/ngrokd -domain ngrok.me</span><br><span class="line">[05/13/15 17:15:37] [INFO] Listening for public http connections on [::]:80</span><br><span class="line">[05/13/15 17:15:37] [INFO] Listening for public https connections on [::]:443</span><br><span class="line">[05/13/15 17:15:37] [INFO] Listening for control and proxy connections on [::]:4443</span><br></pre></td></tr></table></figure><p>启动客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; ./bin/release/ngrok -config=debug.yml -log=ngrok.log -subdomain=test 8080</span><br></pre></td></tr></table></figure><p>有了调试环境，我们就可以通过debug日志验证我们的分析了。</p><p>ngrok的源码结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x   3 tony  staff  102  3 31 16:09 cache/</span><br><span class="line">drwxr-xr-x  16 tony  staff  544  5 13 17:21 client/</span><br><span class="line">drwxr-xr-x   4 tony  staff  136  5 13 15:02 conn/</span><br><span class="line">drwxr-xr-x   3 tony  staff  102  3 31 16:09 <span class="built_in">log</span>/</span><br><span class="line">drwxr-xr-x   4 tony  staff  136  3 31 16:09 main/</span><br><span class="line">drwxr-xr-x   5 tony  staff  170  5 12 16:17 msg/</span><br><span class="line">drwxr-xr-x   5 tony  staff  170  3 31 16:09 proto/</span><br><span class="line">drwxr-xr-x  11 tony  staff  374  5 13 17:21 server/</span><br><span class="line">drwxr-xr-x   7 tony  staff  238  3 31 16:09 util/</span><br><span class="line">drwxr-xr-x   3 tony  staff  102  3 31 16:09 version/</span><br></pre></td></tr></table></figure><p>main目录下的ngrok/和ngrokd/分别是ngrok和ngrokd main包，main函数存放的位置，但这里仅仅是一个stub。以ngrok为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok/src/ngrok/main/ngrok/ngrok.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"ngrok/client"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client.Main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的main被client包的Main函数实现。</p><p>client和server目录分别对应ngrok和ngrokd的主要逻辑，其它目录（或包）都是一些工具类的实现。</p><h2 id="二、第一阶段：Control-Connection建立"><a href="#二、第一阶段：Control-Connection建立" class="headerlink" title="二、第一阶段：Control Connection建立"></a>二、第一阶段：Control Connection建立</h2><p>在ngrokd的启动日志中我们可以看到这样一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Listening for control and proxy connections on [::]:4443</span><br></pre></td></tr></table></figure><p>ngrokd在4443端口（默认）监听control和proxy connection。Control Connection，顾名思义“控制连接”，有些类似于FTP协议的控制连接。该连接 只用于收发控制类消息。作为客户端的ngrok启动后的第一件事就是与ngrokd建立Control Connection，建立过程序列图如下：</p><p><img src="/img/ngrok-control-connection.png" alt="img"></p><p>前面提到过，ngrok客户端的实际entrypoint在ngrok/src/ngrok/client目录下，包名client，实际入口是 client.Main函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/client/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// parse options</span></span><br><span class="line">    <span class="comment">// set up logging</span></span><br><span class="line">    <span class="comment">// read configuration file</span></span><br><span class="line">    … …</span><br><span class="line">    NewController().Run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngrok采用了MVC模式构架代码，这既包括ngrok与ngrokd之间的逻辑处理，也包括ngrok本地web页面（用于隧道数据的 introspection）的处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/client/controller.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctl *Controller)</span> <span class="title">Run</span><span class="params">(config *Configuration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> model *ClientModel</span><br><span class="line">    <span class="keyword">if</span> ctl.model == <span class="literal">nil</span> &#123;</span><br><span class="line">        model = ctl.SetupModel(config)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model = ctl.model.(*ClientModel)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init the model</span></span><br><span class="line">    <span class="comment">// init web ui</span></span><br><span class="line">    <span class="comment">// init term ui</span></span><br><span class="line">   … …</span><br><span class="line">   ctl.Go(ctl.model.Run)</span><br><span class="line">   … …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来继续看看model.Run都做了些什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/client/model.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// run the control channel</span></span><br><span class="line">        c.control()</span><br><span class="line">        … …</span><br><span class="line">        <span class="keyword">if</span> c.connStatus == mvc.ConnOnline &#123;</span><br><span class="line">            wait = <span class="number">1</span> * time.Second</span><br><span class="line">        &#125;</span><br><span class="line">        … …</span><br><span class="line">        c.connStatus = mvc.ConnReconnecting</span><br><span class="line">        c.update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run函数调用c.control来运行Control Connection的主逻辑，并在control connection断开后，尝试重连。</p><p>c.control是ClientModel的一个method，用来真正建立ngrok到ngrokd的control connection，并完成基于ngrok的鉴权（用户名、密码配置在配置文件中）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/client/model.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">control</span><span class="params">()</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        ctlConn conn.Conn</span><br><span class="line">        err     error</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="comment">// simple non-proxied case, just connect to the server</span></span><br><span class="line">        ctlConn, err = conn.Dial(c.serverAddr, <span class="string">"ctl"</span>, c.tlsConfig)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;……&#125;</span><br><span class="line">    … …</span><br><span class="line"></span><br><span class="line">    <span class="comment">// authenticate with the server</span></span><br><span class="line">    auth := &amp;msg.Auth&#123;</span><br><span class="line">        ClientId:  c.id,</span><br><span class="line">        OS:        runtime.GOOS,</span><br><span class="line">        Arch:      runtime.GOARCH,</span><br><span class="line">        Version:   version.Proto,</span><br><span class="line">        MmVersion: version.MajorMinor(),</span><br><span class="line">        User:      c.authToken,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = msg.WriteMsg(ctlConn, auth); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for the server to authenticate us</span></span><br><span class="line">    <span class="keyword">var</span> authResp msg.AuthResp</span><br><span class="line">    <span class="keyword">if</span> err = msg.ReadMsgInto(ctlConn, &amp;authResp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    … …</span><br><span class="line">    c.id = authResp.ClientId</span><br><span class="line">    … ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngrok封装了connection相关操作，代码在<code>ngrok/src/ngrok/conn</code>下面，包名conn。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/conn/conn.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(addr, typ <span class="keyword">string</span>, tlsCfg *tls.Config)</span> <span class="params">(conn *loggedConn, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rawConn net.Conn</span><br><span class="line">    <span class="keyword">if</span> rawConn, err = net.Dial(<span class="string">"tcp"</span>, addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn = wrapConn(rawConn, typ)</span><br><span class="line">    conn.Debug(<span class="string">"New connection to: %v"</span>, rawConn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">        conn.StartTLS(tlsCfg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngrok首先创建一条TCP连接，并基于该连接创建了TLS client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loggedConn)</span> <span class="title">StartTLS</span><span class="params">(tlsCfg *tls.Config)</span></span> &#123;</span><br><span class="line">    c.Conn = tls.Client(c.Conn, tlsCfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过此时并未进行TLS的初始化，即handshake(三次握手)。handshake发生在ngrok首次向ngrokd发送auth消息（msg.WriteMsg, ngrok/src/ngrok/msg/msg.go）时，go标准库的TLS相关函数默默的完成这一handshake过程。我们经常遇到的ngrok证书验证失败等问题，就发生在该过程中。</p><p>在AuthResp中，ngrokd为该<code>Control Connection</code>分配一个ClientID，该ClientID在后续<code>Proxy Connection</code>建立时使用，用于关联和校验之用。可以理解成首先建的Control Connection连接是登录操作，需要进行auth帐号授权，授权成功后获得一个token（这里是ClientID），然后用这个token进行Proxy Connection建立连接。</p><p>前面的逻辑和代码都是ngrok客户端的，现在我们再从ngrokd server端代码review一遍<code>Control Connection</code>的建立过程。</p><p>ngrokd的代码放在<code>ngrok/src/ngrok/server</code>下面，entrypoint如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// parse options</span></span><br><span class="line">    opts = parseArgs()</span><br><span class="line">    <span class="comment">// init logging</span></span><br><span class="line">    <span class="comment">// init tunnel/control registry</span></span><br><span class="line">    … …</span><br><span class="line">    <span class="comment">// start listeners</span></span><br><span class="line">    listeners = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*conn.Listener)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load tls configuration</span></span><br><span class="line">    tlsConfig, err := LoadTLSConfig(opts.tlsCrt, opts.tlsKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// listen for http</span></span><br><span class="line">    <span class="comment">// listen for https</span></span><br><span class="line">    … …</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ngrok clients</span></span><br><span class="line">    tunnelListener(opts.tunnelAddr, tlsConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngrokd启动了三个监听，其中最后一个tunnelListenner用于监听ngrok发起的Control Connection或者后续的proxy connection，作者意图通过一个端口，监听两种类型连接，旨在于方便部署。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">    <span class="comment">// listen for incoming connections</span></span><br><span class="line">    listener, err := conn.Listen(addr, <span class="string">"tun"</span>, tlsConfig)</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">for</span> c := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tunnelConn conn.Conn)</span></span> &#123;</span><br><span class="line">            … …</span><br><span class="line">            <span class="keyword">var</span> rawMsg msg.Message</span><br><span class="line">            <span class="keyword">if</span> rawMsg, err = msg.ReadMsg(tunnelConn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                tunnelConn.Warn(<span class="string">"Failed to read message: %v"</span>, err)</span><br><span class="line">                tunnelConn.Close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            … …</span><br><span class="line">            <span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> *msg.Auth:</span><br><span class="line">                NewControl(tunnelConn, m)</span><br><span class="line">            … …</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tunnelListener可以看到，当ngrokd在新建立的Control Connection上收到Auth消息后，ngrokd执行NewControl来处理该Control Connection上的后续事情。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/control.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the object</span></span><br><span class="line">    c := &amp;Control&#123;</span><br><span class="line">        … …</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// register the clientid</span></span><br><span class="line">    … …</span><br><span class="line">    <span class="comment">// register the control</span></span><br><span class="line">    … …</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the writer first so that</span></span><br><span class="line">    <span class="comment">// the following messages get sent</span></span><br><span class="line">    <span class="keyword">go</span> c.writer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Respond to authentication</span></span><br><span class="line">    c.out &lt;- &amp;msg.AuthResp&#123;</span><br><span class="line">        Version:   version.Proto,</span><br><span class="line">        MmVersion: version.MajorMinor(),</span><br><span class="line">        ClientId:  c.id,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As a performance optimization,</span></span><br><span class="line">    <span class="comment">// ask for a proxy connection up front</span></span><br><span class="line">    c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manage the connection</span></span><br><span class="line">    <span class="keyword">go</span> c.manager()</span><br><span class="line">    <span class="keyword">go</span> c.reader()</span><br><span class="line">    <span class="keyword">go</span> c.stopper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在NewControl中，ngrokd返回了AuthResp。到这里，一条新的Control Connection建立完毕。</p><p>我们最后再来看一下Control Connection建立过程时ngrok和ngrokd的输出日志，增强一下感性认知：</p><p>ngrok Server:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [tun:d866234] New connection from 127.0.0.1:59949</span><br><span class="line">[DEBG] [tun:d866234] Waiting to <span class="built_in">read</span> message</span><br><span class="line">[DEBG] [tun:d866234] Reading message with length: 126</span><br><span class="line">[DEBG] [tun:d866234] Read message &#123;<span class="string">"Type"</span>:<span class="string">"Auth"</span>,</span><br><span class="line"><span class="string">"Payload"</span>:&#123;<span class="string">"Version"</span>:<span class="string">"2"</span>,<span class="string">"MmVersion"</span>:<span class="string">"1.7"</span>,<span class="string">"User"</span>:<span class="string">""</span>,<span class="string">"Password"</span>:<span class="string">""</span>,<span class="string">"OS"</span>:<span class="string">"darwin"</span>,<span class="string">"Arch"</span>:<span class="string">"amd64"</span>,<span class="string">"ClientId"</span>:<span class="string">""</span>&#125;&#125;</span><br><span class="line">[INFO] [ctl:d866234] Renamed connection tun:d866234</span><br><span class="line">[INFO] [registry] [ctl] Registered control with id ac1d14e0634f243f8a0cc2306bb466af</span><br><span class="line">[DEBG] [ctl:d866234] [ac1d14e0634f243f8a0cc2306bb466af] Writing message: &#123;<span class="string">"Type"</span>:<span class="string">"AuthResp"</span>,<span class="string">"Payload"</span>:&#123;<span class="string">"Version"</span>:<span class="string">"2"</span>,<span class="string">"MmVersion"</span>:<span class="string">"1.7"</span>,<span class="string">"ClientId"</span>:<span class="string">"ac1d14e0634f243f8a0cc2306bb466af"</span>,<span class="string">"Error"</span>:<span class="string">""</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>Client:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] (ngrok/log.Info:112) Reading configuration file debug.yml</span><br><span class="line">[INFO] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Info:83) [client] Trusting root CAs: [assets/client/tls/ngrokroot.crt]</span><br><span class="line">[INFO] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Info:83) [view] [web] Serving web interface on 127.0.0.1:4040</span><br><span class="line">[INFO] (ngrok/log.Info:112) Checking <span class="keyword">for</span> update</span><br><span class="line">[DEBG] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [view] [term] Waiting <span class="keyword">for</span> update</span><br><span class="line">[DEBG] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [ctl:31deb681] New connection to: 127.0.0.1:4443</span><br><span class="line">[DEBG] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [ctl:31deb681] Writing message: &#123;<span class="string">"Type"</span>:<span class="string">"Auth"</span>,<span class="string">"Payload"</span>:&#123;<span class="string">"Version"</span>:<span class="string">"2"</span>,<span class="string">"MmVersion"</span>:<span class="string">"1.7"</span>,<span class="string">"User"</span>:<span class="string">""</span>,<span class="string">"Password"</span>:<span class="string">""</span>,<span class="string">"OS"</span>:<span class="string">"darwin"</span>,<span class="string">"Arch"</span>:<span class="string">"amd64"</span>,<span class="string">"ClientId"</span>:<span class="string">""</span>&#125;&#125;</span><br><span class="line">[DEBG] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [ctl:31deb681] Waiting to <span class="built_in">read</span> message</span><br><span class="line">(ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [ctl:31deb681] Reading message with length: 120</span><br><span class="line">(ngrok/<span class="built_in">log</span>.(*PrefixLogger).Debug:79) [ctl:31deb681] Read message &#123;<span class="string">"Type"</span>:<span class="string">"AuthResp"</span>,<span class="string">"Payload"</span>:&#123;<span class="string">"Version"</span>:<span class="string">"2"</span>,<span class="string">"MmVersion"</span>:<span class="string">"1.7"</span>,<span class="string">"ClientId"</span>:<span class="string">"ac1d14e0634f243f8a0cc2306bb466af"</span>,<span class="string">"Error"</span>:<span class="string">""</span>&#125;&#125;</span><br><span class="line">[INFO] (ngrok/<span class="built_in">log</span>.(*PrefixLogger).Info:83) [client] Authenticated with server, client id: ac1d14e0634f243f8a0cc2306bb466af</span><br></pre></td></tr></table></figure><h2 id="四、Tunnel-Creation"><a href="#四、Tunnel-Creation" class="headerlink" title="四、Tunnel Creation"></a>四、Tunnel Creation</h2><p>隧道的创建时序图如下：</p><p><img src="/img/ngrok-tunnel-creation.png" alt=""></p><p>Tunnel Creation是ngrok将配置文件中的tunnel信息通过刚刚建立的Control Connection传输给 ngrokd，ngrokd登记、启动相应端口监听（如果配置了remote_port或多路复用ngrokd默认监听的http和https端口）并返回相应应答。ngrok和ngrokd之间并未真正建立新连接。</p><p>我们回到ngrok的model.go，继续看ClientModel的control方法。在收到AuthResp后，ngrok还做了如下事情：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/client/model.go</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// request tunnels</span></span><br><span class="line">    reqIdToTunnelConfig := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*TunnelConfiguration)</span><br><span class="line">    <span class="keyword">for</span> _, config := <span class="keyword">range</span> c.tunnelConfig &#123;</span><br><span class="line">        <span class="comment">// create the protocol list to ask for</span></span><br><span class="line">        <span class="keyword">var</span> protocols []<span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> proto, _ := <span class="keyword">range</span> config.Protocols &#123;</span><br><span class="line">            protocols = <span class="built_in">append</span>(protocols, proto)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reqTunnel := &amp;msg.ReqTunnel&#123;</span><br><span class="line">            … …</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send the tunnel request</span></span><br><span class="line">        <span class="keyword">if</span> err = msg.WriteMsg(ctlConn, reqTunnel); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// save request id association so we know which local address</span></span><br><span class="line">        <span class="comment">// to proxy to later</span></span><br><span class="line">        reqIdToTunnelConfig[reqTunnel.ReqId] = config</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main control loop</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rawMsg msg.Message</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">switch</span> m := rawMsg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        … …</span><br><span class="line">        <span class="keyword">case</span> *msg.NewTunnel:</span><br><span class="line">            … …</span><br><span class="line"></span><br><span class="line">            tunnel := mvc.Tunnel&#123;</span><br><span class="line">                … …</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c.tunnels[tunnel.PublicUrl] = tunnel</span><br><span class="line">            c.connStatus = mvc.ConnOnline</span><br><span class="line">           </span><br><span class="line">            c.update()</span><br><span class="line">        … …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ngrok将配置的Tunnel信息逐一以ReqTunnel消息发送给ngrokd以注册登记Tunnel，并在随后的main control loop中处理ngrokd回送的NewTunnel消息，完成一些登记索引工作。</p><p>ngrokd Server端对tunnel creation的处理是在NewControl的结尾处：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/control.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControl</span><span class="params">(ctlConn conn.Conn, authMsg *msg.Auth)</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line">    <span class="comment">// manage the connection</span></span><br><span class="line">    <span class="keyword">go</span> c.manager()</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">manager</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//… …</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-reap.C:</span><br><span class="line">            … …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> mRaw, ok := &lt;-c.in:</span><br><span class="line">            <span class="comment">// c.in closes to indicate shutdown</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> m := mRaw.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> *msg.ReqTunnel:</span><br><span class="line">                c.registerTunnel(m)</span><br><span class="line"></span><br><span class="line">            … …</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Control的manager在收到ngrok发来的ReqTunnel消息后，调用registerTunnel进行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok/src/ngrok/server/control.go</span></span><br><span class="line"><span class="comment">// Register a new tunnel on this control connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Control)</span> <span class="title">registerTunnel</span><span class="params">(rawTunnelReq *msg.ReqTunnel)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, proto := <span class="keyword">range</span> strings.Split(rawTunnelReq.Protocol, <span class="string">"+"</span>) &#123;</span><br><span class="line">        tunnelReq := *rawTunnelReq</span><br><span class="line">        tunnelReq.Protocol = proto</span><br><span class="line"></span><br><span class="line">        c.conn.Debug(<span class="string">"Registering new tunnel"</span>)</span><br><span class="line">        t, err := NewTunnel(&amp;tunnelReq, c)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.out &lt;- &amp;msg.NewTunnel&#123;Error: err.Error()&#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(c.tunnels) == <span class="number">0</span> &#123;</span><br><span class="line">                c.shutdown.Begin()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we're done</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add it to the list of tunnels</span></span><br><span class="line">        c.tunnels = <span class="built_in">append</span>(c.tunnels, t)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acknowledge success</span></span><br><span class="line">        c.out &lt;- &amp;msg.NewTunnel&#123;</span><br><span class="line">            Url:      t.url,</span><br><span class="line">            Protocol: proto,</span><br><span class="line">            ReqId:    rawTunnelReq.ReqId,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rawTunnelReq.Hostname = strings.Replace(t.url, proto+<span class="string">"://"</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端创建tunnel的实际工作由NewTunnel完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok/src/ngrok/server/tunnel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTunnel</span><span class="params">(m *msg.ReqTunnel, ctl *Control)</span> <span class="params">(t *Tunnel, err error)</span></span> &#123;</span><br><span class="line">    t = &amp;Tunnel&#123;</span><br><span class="line">      … …</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proto := t.req.Protocol</span><br><span class="line">    <span class="keyword">switch</span> proto &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"tcp"</span>:</span><br><span class="line">        bindTcp := <span class="function"><span class="keyword">func</span><span class="params">(port <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> t.listener, err = net.ListenTCP(<span class="string">"tcp"</span>,</span><br><span class="line">               &amp;net.TCPAddr&#123;IP: net.ParseIP(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">               Port: port&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                … …</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create the url</span></span><br><span class="line">            addr := t.listener.Addr().(*net.TCPAddr)</span><br><span class="line">            t.url = fmt.Sprintf(<span class="string">"tcp://%s:%d"</span>, opts.domain, addr.Port)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// register it</span></span><br><span class="line">            <span class="keyword">if</span> err = tunnelRegistry.RegisterAndCache(t.url, t);</span><br><span class="line">               err != <span class="literal">nil</span> &#123;</span><br><span class="line">                … …</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">go</span> t.listenTcp(t.listener)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the custom remote port you asked for</span></span><br><span class="line">        <span class="keyword">if</span> t.req.RemotePort != <span class="number">0</span> &#123;</span><br><span class="line">            bindTcp(<span class="keyword">int</span>(t.req.RemotePort))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// try to return to you the same port you had before</span></span><br><span class="line">        cachedUrl := tunnelRegistry.GetCachedRegistration(t)</span><br><span class="line">        <span class="keyword">if</span> cachedUrl != <span class="string">""</span> &#123;</span><br><span class="line">            … …</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bind for TCP connections</span></span><br><span class="line">        bindTcp(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"http"</span>, <span class="string">"https"</span>:</span><br><span class="line">        l, ok := listeners[proto]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            … …</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err = registerVhost(t, proto, l.Addr.(*net.TCPAddr).Port);</span><br><span class="line">           err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err = fmt.Errorf(<span class="string">"Protocol %s is not supported"</span>, proto)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    … …</span><br><span class="line"></span><br><span class="line">    metrics.OpenTunnel(t)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，NewTunnel区别对待tcp和http/https隧道：</p><ul><li><p>对于Tcp隧道，NewTunnel先要看是否配置了<code>remote_port</code>，如果<code>remote_port</code>不为空，则启动监听这个<code>remote_port</code>。否则尝试从cache里找出你之前创建tunnel时使用的端口号，如果可用，则监听这个端口号，否则bindTcp(0)，即 随机选择一个端口作为该tcp tunnel的<code>remote_port</code>。</p></li><li><p>对于http/https隧道，ngrokd启动时就默认监听了80和443，如果ngrok请求建立http/https隧道(目前不支持设置<code>remote_port</code>)，则ngrokd通过一种自实现的vhost的机制实现所有http/https请求多路复用到80和443端口上。ngrokd不会新增监听端口。</p></li></ul><p>从下面例子，我们也可以看出一些端倪。我们将debug.yml改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server_addr:</span> <span class="string">ngrok.me:4443</span></span><br><span class="line"><span class="attr">trust_host_root_certs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line"><span class="attr">      test:</span></span><br><span class="line"><span class="attr">        proto:</span></span><br><span class="line"><span class="attr">           http:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      test1:</span></span><br><span class="line"><span class="attr">        proto:</span></span><br><span class="line"><span class="attr">           http:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">      ssh1:</span></span><br><span class="line"><span class="attr">        remote_port:</span> <span class="number">50000</span></span><br><span class="line"><span class="attr">        proto:</span></span><br><span class="line"><span class="attr">            tcp:</span> <span class="number">22</span></span><br><span class="line"><span class="attr">      ssh2:</span></span><br><span class="line"><span class="attr">        proto:</span></span><br><span class="line"><span class="attr">            tcp:</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>启动ngrok：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$./bin/release/ngrok -config=debug.yml -log=ngrok.log start test test1  ssh1 ssh2</span><br><span class="line"></span><br><span class="line">Tunnel Status                 online</span><br><span class="line">Version                       1.7/1.7</span><br><span class="line">Forwarding                    tcp://ngrok.me:50000 -&gt; 127.0.0.1:22</span><br><span class="line">Forwarding                    tcp://ngrok.me:56297 -&gt; 127.0.0.1:22</span><br><span class="line">Forwarding                    http://test.ngrok.me -&gt; 127.0.0.1:8080</span><br><span class="line">Forwarding                    http://test1.ngrok.me -&gt; 127.0.0.1:8081</span><br><span class="line">Web Interface                 127.0.0.1:4040</span><br></pre></td></tr></table></figure><p>可以看出ngrokd为ssh2随机挑选了一个端口56297进行了监听，而两个http隧道，则都默认使用了80端口。</p><p>如果像下面这样配置会发生什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssh1:</span><br><span class="line">        remote_port: 50000</span><br><span class="line">        proto:</span><br><span class="line">            tcp: 22</span><br><span class="line">      ssh2:</span><br><span class="line">        remote_port: 50000</span><br><span class="line">        proto:</span><br><span class="line">            tcp: 22</span><br></pre></td></tr></table></figure><p>ngrok启动会得到错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server failed to allocate tunnel: [ctl:5332a293] [a87bd111bcc804508c835714c18a5664] Error binding TCP listener: listen tcp 0.0.0.0:50000: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use</span><br></pre></td></tr></table></figure><p>客户端ngrok在ClientModel control方法的main control loop中收到NewTunnel并处理该消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> *msg.NewTunnel:</span><br><span class="line">            <span class="keyword">if</span> m.Error != <span class="string">""</span> &#123;</span><br><span class="line">                … …</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tunnel := mvc.Tunnel&#123;</span><br><span class="line">                PublicUrl: m.Url,</span><br><span class="line">                LocalAddr: reqIdToTunnelConfig[m.ReqId].Protocols[m.Protocol],</span><br><span class="line">                Protocol:  c.protoMap[m.Protocol],</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c.tunnels[tunnel.PublicUrl] = tunnel</span><br><span class="line">            c.connStatus = mvc.ConnOnline</span><br><span class="line">            c.Info(<span class="string">"Tunnel established at %v"</span>, tunnel.PublicUrl)</span><br><span class="line">            c.update()</span><br></pre></td></tr></table></figure><h2 id="五、Proxy-Connection和Private-Connection"><a href="#五、Proxy-Connection和Private-Connection" class="headerlink" title="五、Proxy Connection和Private Connection"></a>五、Proxy Connection和Private Connection</h2><p>到目前为止，我们知道了Control Connection：用于ngrok和ngrokd之间传输命令；Public Connection：外部发起的，尝试向内网服务建立的链接。</p><p>这节当中，我们要接触到Proxy Connection和Private Connection。</p><p>Proxy Connection以及Private Connection的建立过程如下：</p><p><img src="/img/ngrok-proxy-connection.png" alt=""></p><p>前面ngrok和ngrokd的交互进行到了NewTunnel，这些数据都是通过之前已经建立的Control Connection上传输的。</p><p>ngrokd侧，NewControl方法的结尾有这样一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// As a performance optimization, ask for a proxy connection up front</span></span><br><span class="line">c.out &lt;- &amp;msg.ReqProxy&#123;&#125;</span><br></pre></td></tr></table></figure><p>服务端ngrokd在Control Connection上向ngrok发送了”ReqProxy”的消息，意为请求ngrok向ngrokd建立一条Proxy Connection，该链接将作为隧道数据流的承载者。</p><p>客户端ngrok在ClientModel control方法的main control loop中收到ReqProxy并处理该消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> *msg.ReqProxy:</span><br><span class="line">            c.ctl.Go(c.proxy)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Establishes and manages a tunnel proxy connection with the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ClientModel)</span> <span class="title">proxy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.proxyUrl == <span class="string">""</span> &#123;</span><br><span class="line">        remoteConn, err = conn.Dial(c.serverAddr, <span class="string">"pxy"</span>, c.tlsConfig)</span><br><span class="line">    &#125;……</span><br><span class="line"></span><br><span class="line">    err = msg.WriteMsg(remoteConn, &amp;msg.RegProxy&#123;ClientId: c.id&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteConn.Error(<span class="string">"Failed to write RegProxy: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngrok客户端收到ReqProxy后，创建一条新连接到ngrokd，该连接即为Proxy Connection。并且ngrok将RegProxy消息通过该新建立的Proxy Connection发到ngrokd，以便ngrokd将该Proxy Connection与对应的Control Connection以及tunnel关联在一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelListener</span><span class="params">(addr <span class="keyword">string</span>, tlsConfig *tls.Config)</span></span> &#123;</span><br><span class="line">    …. …</span><br><span class="line">    <span class="keyword">case</span> *msg.RegProxy:</span><br><span class="line">                NewProxy(tunnelConn, m)</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止, tunnel、Proxy Connection都已经建立了，万事俱备，就等待Public发起Public connection到ngrokd了。</p><p>下面我们以Public发起一个http连接到ngrokd为例，比如我们通过curl 命令，向test.ngrok.me发起一次http请求。</p><p>前面说过，ngrokd在启动时默认启动了80和443端口的监听，并且与其他http/https隧道共同多路复用该端口（通过vhost机制)。ngrokd server对80端口的处理代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok/src/ngrok/server/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line"> <span class="comment">// listen for http</span></span><br><span class="line">    <span class="keyword">if</span> opts.httpAddr != <span class="string">""</span> &#123;</span><br><span class="line">        listeners[<span class="string">"http"</span>] =</span><br><span class="line">          startHttpListener(opts.httpAddr, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startHttpListener针对每个连接，启动一个goroutine专门处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/http.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHttpListener</span><span class="params">(addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    tlsCfg *tls.Config)</span> <span class="params">(listener *conn.Listener)</span></span> &#123;</span><br><span class="line">    <span class="comment">// bind/listen for incoming connections</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> listener, err = conn.Listen(addr, <span class="string">"pub"</span>, tlsCfg);</span><br><span class="line">        err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proto := <span class="string">"http"</span></span><br><span class="line">    <span class="keyword">if</span> tlsCfg != <span class="literal">nil</span> &#123;</span><br><span class="line">        proto = <span class="string">"https"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   … …</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> conn := <span class="keyword">range</span> listener.Conns &#123;</span><br><span class="line">            <span class="keyword">go</span> httpHandler(conn, proto)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handles a new http connection from the public internet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpHandler</span><span class="params">(c conn.Conn, proto <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line">    <span class="comment">// let the tunnel handle the connection now</span></span><br><span class="line">    tunnel.HandlePublicConnection(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们终于看到server端处理public connection的真正方法了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngrok/src/ngrok/server/tunnel.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span> <span class="title">HandlePublicConnection</span><span class="params">(publicConn conn.Conn)</span></span> &#123;</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">var</span> proxyConn conn.Conn</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; (<span class="number">2</span> * proxyMaxPoolSize); i++ &#123;</span><br><span class="line">        <span class="comment">// get a proxy connection</span></span><br><span class="line">        <span class="keyword">if</span> proxyConn, err = t.ctl.GetProxy();</span><br><span class="line">           err != <span class="literal">nil</span> &#123;</span><br><span class="line">            … …</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> proxyConn.Close()</span><br><span class="line">       … …</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tell the client we're going to</span></span><br><span class="line">        <span class="comment">// start using this proxy connection</span></span><br><span class="line">        startPxyMsg := &amp;msg.StartProxy&#123;</span><br><span class="line">            Url:        t.url,</span><br><span class="line">            ClientAddr: publicConn.RemoteAddr().String(),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err = msg.WriteMsg(proxyConn, startPxyMsg);</span><br><span class="line">            err != <span class="literal">nil</span> &#123;</span><br><span class="line">           … …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    … …</span><br><span class="line">    <span class="comment">// join the public and proxy connections</span></span><br><span class="line">    bytesIn, bytesOut := conn.Join(publicConn, proxyConn)</span><br><span class="line">    …. …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlePublicConnection通过选出的Proxy connection向ngrok client发送StartProxy信息，告知ngrok proxy启动。然后通过conn.Join方法将publicConn和proxyConn关联到一起。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngrok/src/ngrok/conn/conn.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(c Conn, c2 Conn)</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    pipe := <span class="function"><span class="keyword">func</span><span class="params">(to Conn, from Conn, bytesCopied *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> to.Close()</span><br><span class="line">        <span class="keyword">defer</span> from.Close()</span><br><span class="line">        <span class="keyword">defer</span> wait.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line">        *bytesCopied, err = io.Copy(to, from)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            from.Warn(<span class="string">"Copied %d bytes to %s before failing with error %v"</span>, *bytesCopied, to.Id(), err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            from.Debug(<span class="string">"Copied %d bytes to %s"</span>, *bytesCopied, to.Id())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">var</span> fromBytes, toBytes <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">go</span> pipe(c, c2, &amp;fromBytes)</span><br><span class="line">    <span class="keyword">go</span> pipe(c2, c, &amp;toBytes)</span><br><span class="line">    c.Info(<span class="string">"Joined with connection %s"</span>, c2.Id())</span><br><span class="line">    wait.Wait()</span><br><span class="line">    <span class="keyword">return</span> fromBytes, toBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Join通过io.Copy实现public conn和proxy conn数据流的转发，单向被称作一个pipe，Join建立了两个Pipe，实现了双向转发，每个Pipe直到一方返回EOF或异常失败才会退出。后续在ngrok端，proxy conn和private conn也是通过conn.Join关联到一起的。</p><p>我们现在就来看看ngrok在收到StartProxy消息后是如何处理的。我们回到ClientModel的proxy方法中。在向ngrokd成功建立proxy connection后，ngrok等待ngrokd的StartProxy指令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wait for the server to ack our register</span></span><br><span class="line">    <span class="keyword">var</span> startPxy msg.StartProxy</span><br><span class="line">    <span class="keyword">if</span> err = msg.ReadMsgInto(remoteConn, &amp;startPxy);</span><br><span class="line">             err != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteConn.Error(<span class="string">"Server failed to write StartProxy: %v"</span>,</span><br><span class="line">                   err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一旦收到StartProxy，ngrok将建立一条private connection：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start up the private connection</span></span><br><span class="line">    start := time.Now()</span><br><span class="line">    localConn, err := conn.Dial(tunnel.LocalAddr, <span class="string">"prv"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       … …</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并将private connection和proxy connection通过conn.Join关联在一起，实现数据透明转发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m.connTimer.Time(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        localConn := tunnel.Protocol.WrapConn(localConn,</span><br><span class="line">             mvc.ConnectionContext&#123;Tunnel: tunnel,</span><br><span class="line">              ClientAddr: startPxy.ClientAddr&#125;)</span><br><span class="line">        bytesIn, bytesOut := conn.Join(localConn, remoteConn)</span><br><span class="line">        m.bytesIn.Update(bytesIn)</span><br><span class="line">        m.bytesOut.Update(bytesOut)</span><br><span class="line">        m.bytesInCount.Inc(bytesIn)</span><br><span class="line">        m.bytesOutCount.Inc(bytesOut)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>这样一来，public connection上的数据通过proxy connection到达ngrok，ngrok再通过private connection将数据转发给本地启动的服务程序，从而实现所谓的内网穿透。从public视角来看，就像是与内网中的那个服务直接交互一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sunansheng/article/details/48372149&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载地址:https://blog.csdn.net/sunansheng/article/details/48372149&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;家里服务器的访问使用的就是ngrok服务：ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost”，这个诠释有两层含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。&lt;/li&gt;
&lt;li&gt;支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。&lt;/p&gt;
&lt;p&gt;今天我们就来简单分析一下这款强大工具的实现原理。ngrok本身是用go语言实现的，需要go 1.1以上版本编译。ngrok官方代码最新版为1.7，作者似乎已经完成了ngrok 2.0版本，但不知为何迟迟不放出最新代码。因此这里我们就以ngrok 1.7版本源码作为原理分析的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://blog.ku-cat.com/categories/go/"/>
    
    
      <category term="go" scheme="http://blog.ku-cat.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>async和await浅析</title>
    <link href="http://blog.ku-cat.com/2018/06/27/node-async-await/"/>
    <id>http://blog.ku-cat.com/2018/06/27/node-async-await/</id>
    <published>2018-06-27T07:23:22.000Z</published>
    <updated>2018-06-27T07:27:18.422Z</updated>
    
    <content type="html"><![CDATA[<p>要理解async和await的用法，首先要了解Task相关知识，这里不做说明，因为这不是本文的重点。</p><p>如果你已经对Task很了解，那么如何使用async和await，在此主要总结了以下三点：</p><ol><li>只有在async方法里面才能使用await操作符；</li><li>await操作符是针对Task对象的；</li><li>当方法A调用方法B,方法B方法体内又通过await调用方法C时，如果方法C内部有异步操作，则方法B会等待异步操作执行完，才往下执行；但方法A可以继续往下执行，不用再等待B方法执行完。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要理解async和await的用法，首先要了解Task相关知识，这里不做说明，因为这不是本文的重点。&lt;/p&gt;
&lt;p&gt;如果你已经对Task很了解，那么如何使用async和await，在此主要总结了以下三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只有在async方法里面才能使用await
      
    
    </summary>
    
      <category term="node" scheme="http://blog.ku-cat.com/categories/node/"/>
    
    
      <category term="node" scheme="http://blog.ku-cat.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>斗地主的Ai算法设计思路</title>
    <link href="http://blog.ku-cat.com/2018/06/25/poke-ai/"/>
    <id>http://blog.ku-cat.com/2018/06/25/poke-ai/</id>
    <published>2018-06-25T08:03:17.000Z</published>
    <updated>2018-06-25T08:11:30.979Z</updated>
    
    <content type="html"><![CDATA[<p>感谢原作者：</p><p>我以前写过一个斗地主机器人。思路如下，希望对你有帮助。</p><p>斗地主AI设计 </p><a id="more"></a><p>一、牌型          </p><p>1 火箭：大小王在一起的牌型，即双王牌，此牌型最大，什么牌型都可以打。         </p><p>2 炸弹：相同点数的四张牌在一起的牌型，比如四条A。除火箭外，它可以打任何牌型，炸弹对炸弹时，要比大小。         </p><p>3 单支（一手牌）：单张牌，如一支3。         </p><p>4 对子（一手牌）：相同点数的两张牌在一起的牌型，比如55。        </p><p>5 三条：相同点数的三张牌在一起的牌型，比如三条4。        </p><p>6 三带一手：三条 ＋ 一手牌的牌型，比如AAA+9或AAA+77。         </p><p>7 单顺：五张或更多的连续单支牌组成的牌型，比如45678或345678910JQKA。2和大小王不可以连。          </p><p>8 双顺：三对或更多的连续对子组成的牌型，比如334455或445566778899。2和大小王不可以连。          </p><p>9 三顺：二个或更多的连续三条组成的牌型，比如777888或444555666777。2和大小王不可以连。         </p><p>10 飞机带翅膀：三顺 ＋ 同数量的一手牌，比如777888+3+6或444555666+33+77+88。  </p><p>11 四带二：四条+两手牌。比如AAAA+7+9或9999+33+55。</p><p>二、牌型分析  </p><p>1 单顺的确定        </p><p>a) 选取五连，先取出最小的一个五连，再在剩余的牌中取出最小的一个五连，依此类推，直到没有五连为止。          </p><p>b) 扩展五连，将剩余的牌与已经取出的牌进行比对，如果某张剩余的牌与已知的连牌能组成更大的连牌，则将其合并。一直到无法合并为止。          </p><p>c) 合并连牌，如果某两组连牌能无缝连接成更大的连牌，则将其合并成一组。         </p><p>经过上述选取、扩展和合并，则将一手牌中的所有连牌提取出来了，举例如下：          </p><p>假定一手牌是：2AKQJ1099877766543          </p><p>第一步，选取出34567，678910两个连牌组。剩余的牌还有79JQKA2         </p><p>第二步，剩余的JQKA能和678910组成新的连牌678910JQKA。          </p><p>第三步，已知的两个连牌组不能合并成新的、更大的连牌组，则这手牌就被分成了34567、678910JQKA两个连牌组和7、9、2三张单牌。    </p><p>2 双顺的确定 将一副牌中所有的对子检测出来，然后将对子排序，按照检测三连的方式可以将所有的双顺都提取出来。   </p><p>3 三条的确定 一副牌中的所有三条都能比较方便地提取出来。   </p><p>4 三顺的确定 在三条的基础上进行比较，如果有相连的三条，则将其合并成（尽可能大的）三顺。   </p><p>5 炸弹的确定 所有的四头都能很方便地确定。   </p><p>6 火箭的确定 只要牌张包含大小王，就将其组成火箭。    </p><p>7 牌张的分类方法          </p><p>a) 先确定火箭：判断是否有大小王。         </p><p>b) 再确定炸弹：判明是否有四头。          </p><p>c) 再确定三条：在除了炸弹以外的牌中判断是否包含三条。          </p><p>d) 再确定三顺：在已经确定的三条中判断是否包含相邻的三条，如果有，则将其组成三顺。注意，应该使三顺的数量尽可能大。即如果有444555666，则将其合成一个三顺，而不是分成444555一个三顺和666一个三条。         </p><p>e) 再确定单顺：判断单顺时必须去除四个2以外的所有炸弹。首先判断是否存在除了三条牌（这里的三条是指所有的三条）以外的连牌，如果有，则将其提取出来。其 次，将剩余的牌与每一个三条（不包含三顺）进行试组合，如果能够重新组成单顺和对子，则将原有的三条取消，重新组合成连牌和单顺（例子4566678重新 组成45678和66）。最后，将已知的连牌、三条（不包含三顺）和剩下的牌张再试组合，将所有如45678（已知的连牌）999（三条）10J（单 牌），重新组合成45678910J和99。通过以上的方法，就能将连牌和三条很好地重新组合。        </p><p>f) 再确定双顺：首先，如果两单顺牌完全重合，则将其重新组合成双顺。其次，在除炸弹、三顺、三条、单顺以外的牌中检测是否包含双顺。如果有，将其提取出来。         </p><p>g) 再确定对子：在炸弹、三顺、三条、连牌、双顺以外的牌中检测是否存在对子，如果存在将其提取出来。          </p><p>h) 再确定单牌：除了炸弹、三顺、三条、连牌、双顺、对子以外的所有牌张都是单牌。    </p><p>8 对子的确定 参见上一节的“再确定对子”。   </p><p> 9 单牌的确定 参见上一节的“再确定单牌”。    </p><p>三、一手牌的手数分析 为 了使斗地主机器人有一定的智能，必须对一手牌的手数进行分析。所谓一手牌的手数，指的是在没有别人压牌的情况下需要出几把能将牌出完。这个数字在经过上面 的分类后是可以确定的。还以上面的一手牌22AAKQJ9987776654为例，这手牌按照前面的分析方法可以分析出以下的牌型：22、AA、K、Q、J、987654、9、77、6的牌型通过对上面牌型的计算，可以容易得出这手牌需要9手才能出完，因此这手牌的手数就是9。    </p><p>四、绝对手数和相对手数的概念  </p><p>因为在斗地主游戏中存在火箭或炸弹的可能，所以理论上只有火箭才不可能被别人压住，所以，可以不考虑相对手数的概念。以后都简称手数。   </p><p>五、叫牌原则分析 </p><p>因为在斗地主中，火箭、炸弹、王和2可以认为是大牌，所以叫牌需要按照这些牌的多少来判断。下面是一个简单的原则：假定火箭为8分，炸弹为6分，大王4分，小王3分，一个2为2分，则当分数大于等于7分时叫三倍；大于等于5分时叫二倍；大于等于3分时叫一倍；小于三分不叫。    </p><p>六、出牌的一般原则</p><p>1 出牌的原则一般按照从小到大的原则，即首先出包含最小牌的组合（单牌、对子、双顺、连牌、三顺、三条等，炸弹、火箭不包括在内）。          </p><p>2 三条的出牌原则：因为三条出牌可以带一张单牌或一个对子，所以在出三条时需要检测是否有单牌，如果有，则带一张最小的单牌，如果没有，则再检测是否存在对子，如果有，则跟一个最小的对子，如果单牌和对子都没有，则出三条。在带牌时，除非是只剩两手牌，否则不能带王或2。          </p><p>3 三顺的出牌原则：因为三顺出牌可以带两张（或更多）单牌或两个（或更多）对子，所以与出三条一样，需要检测是否有单牌或对子。如果有足够多的单牌或对子， 则将其带出。如果有单牌，但没有足够多的单牌，则检查是否有6连以上的连牌，如果有将连牌的最小张数当作单牌带出。如果有对子，但没有足够多的对子，则检 查是否有4连以上的双顺，如果有将双顺的最小对子当作对子带出。在带牌时，除非是只剩两手牌，否则不能带王或2。          </p><p>4 连牌的出牌原则：直接出。          </p><p>5 双顺的出牌原则：直接出。          </p><p>6 对子的出牌原则：因为对子可以用三条、三顺等带出，所以在出对子时，应该先检测一下三条＋三顺（中三条）的数量，如果所有三条数量 &lt;= 对子＋单牌数量总和－2时，出对子，否则出三带2等等。          </p><p>7 单牌的出牌原则：因为单牌可以用三条、三顺等带出，所以在出单牌时，应该先检测一下三条＋三顺（中三条）的数量，如果所有三条数量 &lt;= 对子＋单牌数量总和－2时，出单牌，否则出三带1等等。    </p><p>七、跟牌的一般原则         </p><p>1 如果手中有独立的，与所出的牌一样牌型的牌时，先跟之。        </p><p>2 2可以作为单牌、对子、三条等形式跟出。          </p><p>3 当手中没有相应牌跟时，如果是本方人员出的牌，可以不跟，如果是对方出的牌，则必须拆牌跟，如果再没有，出炸弹或火箭，否则PASS。          </p><p>4 如果手中的牌除了炸弹。火箭外还剩一手牌，则如果牌型相符，则先跟之，否则炸之。          </p><p>5 单牌的跟牌原则：如果手中有单牌，则跟之，否则拆2跟之，否则拆对牌跟之，否则拆6连以上的单顺顶张跟之，否则拆三条跟之，否则拆三顺跟之，否则拆5连单顺跟之，否则拆双顺跟之，否则炸之，否则PASS。          </p><p>6 对牌的根牌原则：如果手中有对子，则跟之，否则拆4连以上的双顺顶张跟之，否则拆三条跟之，否则拆双顺跟之，否则拆三顺跟之，否则炸之，否则PASS。          </p><p>7 三条、三带1、三带2等牌的根牌原则：如果手中有相同牌型的牌则跟之，否则拆三顺跟之，否则炸之，否则PASS。注意，只有在手中牌在出了以后还剩一手牌时，或直接出完的情况下，才允许带王或2。在没有足够牌带的情况下，参照单牌。对子的拆牌原则进行拆牌处理。          </p><p>8 三顺及三顺带牌的根牌原则：如果有相应的牌型，则跟之，否则可以将大的三顺拆成小的三顺跟之，否则炸之，否则PASS。注意，只有在手中牌在出了以后还剩一手牌时，或直接出完的情况下，才允许带王或2。在没有足够牌带的情况下，参照单牌。对子的拆牌原则进行拆牌处理。         </p><p>9 连牌的跟牌原则：如果有相应的牌型，则跟之，否则拆相同张数的双顺，否则拆相同张数的三顺，否则拆不同张数的连牌，否则拆不同张数的双顺，否则拆不同张数的三顺，否则炸之，否则PASS。          </p><p>10 双顺的跟牌原则：有相同牌型的牌，则跟之，否则拆不同张数的双顺，否则拆不同张数的三顺，否则拆相同张数的三顺，否则炸之，否则PASS。         </p><p>11 炸弹的跟牌原则：有超过所出炸弹的炸弹，或有火箭，则炸之，否则PASS。         </p><p>12 炸弹带两手牌的跟牌原则：如果有炸弹，则炸之，否则PASS。   </p><p>八、打牌原则解析          </p><p>1 坐庄打法：因为坐庄的只是自己一个人，不存在配合问题，所以一般按照前面的原则出牌即可。                  </p><p>a) 在出牌时，如果偏家有一个人只剩一张牌时，尽量不出单牌，否则单牌由大到小出。                  </p><p>b) 在跟牌时，如果偏家有一个人只剩一张牌时，跟手中最大的牌。          </p><p>2 偏家打法：偏家因为牵涉到配合问题，所以打法有一些不同。                  </p><p>a) 在出牌时，如果是庄家的上家，且庄家只剩一张牌时，尽量不出单牌，否则单牌由大到小出。                  </p><p>b) 在跟牌时，如果是庄家的上家，且庄家只剩一张牌时，跟手中最大的牌。                 </p><p>c) 当一个偏家打出的是单牌时，一般情况下能跟就跟。如果手中必须跟2或以上的牌时，选择PASS。                  </p><p>d) 当一个偏家打出的是对子时，一般情况下能跟就跟。如果手中必须跟AA或以上的牌时，选择PASS。                  </p><p>e) 如果一个偏家打出的牌是除了单牌及对子以外的牌型，则选择PASS。                  </p><p>f) 如果处在下家的偏家只剩一张牌时，在出牌时出手中最小的牌。跟牌还按照一般的原则。           </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢原作者：&lt;/p&gt;
&lt;p&gt;我以前写过一个斗地主机器人。思路如下，希望对你有帮助。&lt;/p&gt;
&lt;p&gt;斗地主AI设计 &lt;/p&gt;
    
    </summary>
    
      <category term="game" scheme="http://blog.ku-cat.com/categories/game/"/>
    
    
      <category term="game" scheme="http://blog.ku-cat.com/tags/game/"/>
    
      <category term="poke" scheme="http://blog.ku-cat.com/tags/poke/"/>
    
      <category term="ai" scheme="http://blog.ku-cat.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>c++ 函数指针</title>
    <link href="http://blog.ku-cat.com/2018/06/19/c-function/"/>
    <id>http://blog.ku-cat.com/2018/06/19/c-function/</id>
    <published>2018-06-19T06:35:01.000Z</published>
    <updated>2018-06-19T07:44:06.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数指针的基础知识"><a href="#函数指针的基础知识" class="headerlink" title="函数指针的基础知识"></a>函数指针的基础知识</h3><h3 id="函数绵是针示例"><a href="#函数绵是针示例" class="headerlink" title="函数绵是针示例"></a>函数绵是针示例</h3><h3 id="深入探讨函数指针"><a href="#深入探讨函数指针" class="headerlink" title="深入探讨函数指针"></a>深入探讨函数指针</h3><h4 id="函数指针数组的表示"><a href="#函数指针数组的表示" class="headerlink" title="函数指针数组的表示"></a>函数指针数组的表示</h4><p>鉴于需要使用三个函数，如果有一个函数指针数组将很方便，这样，将可使用for循环通过指针依次调用每个函数。如何声明这样的数组呢？显然，这种声明类似单个函数指针的声明，但必须在某个地方加上<figure class="highlight plain"><figcaption><span>。答案如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">const double * (*pa[3])(const double *, int) = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure></p><p>为何将[3]放在这个地方呢？pa是一个包含三个元素的数组，而要声明这样的数组，首先要使用pa[3]。该声明的其它部分指出了数组包含的元素是什么样的。运算符[]的优先级高于*，因此<figure class="highlight plain"><figcaption><span>double *, int```，且返回值类型为 ```const double *```的函数。 因此， pa是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将```const double * 和 int作为参数，并返回一个````const duble*```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####如何使用：</span><br><span class="line"></span><br><span class="line">因为 pa[i] 都表示数组中的指针，因此可将任何一种函数调用表示法用于它们：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">const double * px = pa[0](av, 3);</span><br><span class="line">const double * py = (*pb[1])(av, 3);</span><br></pre></td></tr></table></figure></p><p>要获取指向double的值，可以使用运算符*：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x= *pa[<span class="number">0</span>](av, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> y = *(*pb[<span class="number">1</span>])(av, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可做的另一件事是创建指向整个数组的指针。由于数组名pa是指向函数指针的指针，因此指向数组的指针将是这样的指针，即它指向指针的指针。看上去挺复杂的，但是由于可使用单个值对其进行初始化，因此可使用auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pc = &amp;pa;<span class="comment">//c++11 automatic type deduction</span></span><br><span class="line"></span><br><span class="line">*pd[<span class="number">3</span>] <span class="comment">//an array of 3 pointers</span></span><br><span class="line">(*pd)[<span class="number">3</span>] <span class="comment">//a pointer to an array of 3 elements</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数指针的基础知识&quot;&gt;&lt;a href=&quot;#函数指针的基础知识&quot; class=&quot;headerlink&quot; title=&quot;函数指针的基础知识&quot;&gt;&lt;/a&gt;函数指针的基础知识&lt;/h3&gt;&lt;h3 id=&quot;函数绵是针示例&quot;&gt;&lt;a href=&quot;#函数绵是针示例&quot; class=&quot;he
      
    
    </summary>
    
      <category term="c/c++" scheme="http://blog.ku-cat.com/categories/c-c/"/>
    
    
      <category term="c++" scheme="http://blog.ku-cat.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>es6 扩展运算符 spread(...)</title>
    <link href="http://blog.ku-cat.com/2018/05/31/js-es6-spread/"/>
    <id>http://blog.ku-cat.com/2018/05/31/js-es6-spread/</id>
    <published>2018-05-31T01:44:30.000Z</published>
    <updated>2018-05-31T01:52:23.601Z</updated>
    
    <content type="html"><![CDATA[<p>1  含义<br>扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  </span><br><span class="line"><span class="comment">// 1 2 3  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)  </span><br><span class="line"><span class="comment">// 1 2 3 4 5  </span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]  </span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>该运算符主要用于函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;  </span><br><span class="line">array.push(...items);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> x + y;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];  </span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。<br>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;  </span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];  </span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>2 替代数组的 apply 方法</p><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </span><br><span class="line">f.apply(<span class="literal">null</span>, args);  </span><br><span class="line"><span class="comment">// ES6 的写法  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法  </span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </span><br><span class="line"><span class="comment">// ES6 的写法  </span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])  </span><br><span class="line"><span class="comment">//  等同于  </span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><p>上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。<br>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法  </span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);  </span><br><span class="line"><span class="comment">// ES6 的写法  </span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];  </span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。<br>下面是另外一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5  </span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))  </span><br><span class="line"><span class="comment">// ES6  </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>3  扩展运算符的应用<br>（ 1 ）合并数组<br>扩展运算符提供了数组合并的新写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5  </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)  </span><br><span class="line"><span class="comment">// ES6  </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]  </span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];  </span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];  </span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];  </span><br><span class="line"><span class="comment">// ES5 的合并数组  </span></span><br><span class="line">arr1.concat(arr2, arr3);  </span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]  </span></span><br><span class="line"><span class="comment">// ES6 的合并数组  </span></span><br><span class="line">[...arr1, ...arr2, ...arr3]  </span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure><p>（ 2 ）与解构赋值结合<br>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5  </span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)  </span><br><span class="line"><span class="comment">// ES6  </span></span><br><span class="line">[a, ...rest] = list  </span><br><span class="line">下面是另外一些例子。  </span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line">first <span class="comment">// 1  </span></span><br><span class="line">rest <span class="comment">// [2, 3, 4, 5]  </span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];  </span><br><span class="line">first <span class="comment">// undefined  </span></span><br><span class="line">rest <span class="comment">// []:  </span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];  </span><br><span class="line">first <span class="comment">// "foo"  </span></span><br><span class="line">rest <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="comment">//  报错  </span></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  </span><br><span class="line"><span class="comment">//  报错</span></span><br></pre></td></tr></table></figure><p>（ 3 ）函数的返回值<br>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateFields = readDateFields(database);  </span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);</span><br></pre></td></tr></table></figure><p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</p><p>（ 4 ）字符串</p><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]  </span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4  </span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> [...str].length;  </span><br><span class="line">&#125;  </span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;  </span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)  </span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'  </span></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)  </span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p><p>（ 5 ）实现了 Iterator 接口的对象</p><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);  </span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 接口。<br>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;  </span><br><span class="line"><span class="string">'0'</span>: <span class="string">'a'</span>,  </span><br><span class="line"><span class="string">'1'</span>: <span class="string">'b'</span>,  </span><br><span class="line"><span class="string">'2'</span>: <span class="string">'c'</span>,  </span><br><span class="line">length: <span class="number">3</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.  </span></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p><p>（ 6 ） Map 和 Set 结构， Generator 函数</p><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([  </span><br><span class="line">[<span class="number">1</span>, <span class="string">'one'</span>],  </span><br><span class="line">[<span class="number">2</span>, <span class="string">'two'</span>],  </span><br><span class="line">[<span class="number">3</span>, <span class="string">'three'</span>],  </span><br><span class="line">]);  </span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">yield</span> <span class="number">3</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。<br>如果对没有iterator接口的对象，使用扩展运算符，将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;  </span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1  含义&lt;br&gt;扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
  </entry>
  
</feed>
